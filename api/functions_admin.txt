<?php

// --- 1. CONFIGURACIÓN DEL SISTEMA ---

function admin_get_settings($pdo) {
    try {
        $stmt = $pdo->query("SELECT * FROM system_settings WHERE id = 1");
        $settings = $stmt->fetch(PDO::FETCH_ASSOC);
        if ($settings) {
            $settings['categoryPrices'] = json_decode($settings['categoryPrices'] ?? '{}', true);
            $settings['customCategories'] = json_decode($settings['customCategories'] ?? '[]', true);
            $settings['ftpSettings'] = json_decode($settings['ftpSettings'] ?? 'null', true);
            $settings['vipPlans'] = json_decode($settings['vipPlans'] ?? '[]', true);
            $settings['paqueteMapper'] = json_decode($settings['paqueteMapper'] ?? '{}', true);
            respond(true, $settings);
        }
        respond(false, null, 'Settings not found');
    } catch (Exception $e) {
        respond(false, null, $e->getMessage());
    }
}

function admin_update_settings($pdo, $input) {
    $s = $input['settings'] ?? [];
    if (empty($s)) respond(true);

    $map = [
        'downloadStartTime' => 'downloadStartTime', 'downloadEndTime' => 'downloadEndTime',
        'isQueuePaused' => 'isQueuePaused', 'batchSize' => 'batchSize',
        'maxDuration' => 'maxDuration', 'maxResolution' => 'maxResolution',
        'pexelsKey' => 'pexelsKey', 'pixabayKey' => 'pixabayKey',
        'geminiKey' => 'geminiKey', 'ytDlpPath' => 'ytDlpPath',
        'enableYoutube' => 'enableYoutube', 'autoTranscode' => 'autoTranscode',
        'transcodePreset' => 'transcodePreset',
        'categoryPrices' => 'categoryPrices', 'customCategories' => 'customCategories',
        'localLibraryPath' => 'localLibraryPath', 'ftpSettings' => 'ftpSettings',
        'videoCommission' => 'videoCommission', 'marketCommission' => 'marketCommission',
        'vipPlans' => 'vipPlans', 'paymentInstructions' => 'paymentInstructions',
        'paqueteMapper' => 'paqueteMapper', 'tropipayClientId' => 'tropipayClientId',
        'tropipayClientSecret' => 'tropipayClientSecret', 'currencyConversion' => 'currencyConversion',
        'proxyUrl' => 'proxyUrl'
    ];

    $fields = []; $params = [];
    foreach ($map as $key => $col) {
        if (array_key_exists($key, $s)) {
            $fields[] = "$col = ?";
            $val = $s[$key];
            if (is_array($val)) $val = json_encode($val, JSON_UNESCAPED_UNICODE);
            else if (is_bool($val)) $val = $val ? 1 : 0;
            else if ($val === '') $val = null;
            $params[] = $val;
        }
    }
    if (empty($fields)) respond(true);
    try {
        $sql = "UPDATE system_settings SET " . implode(', ', $fields) . " WHERE id = 1";
        $pdo->prepare($sql)->execute($params);
        respond(true);
    } catch (Exception $e) { respond(false, null, $e->getMessage()); }
}

// --- 2. TRANSCODER ENGINE ---

function safe_shell_arg($arg) {
    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {
        // En Windows, escapeshellarg a veces rompe rutas con espacios si no se maneja bien
        return '"' . str_replace('"', '', $arg) . '"';
    }
    return escapeshellarg($arg);
}

function check_ffmpeg_available() {
    if (!function_exists('exec')) return false;
    $isWin = strtoupper(substr(PHP_OS, 0, 3)) === 'WIN';
    $cmd = $isWin ? 'ffmpeg -version 2>&1' : 'ffmpeg -version 2>&1';
    @exec($cmd, $output, $resultCode);
    return ($resultCode === 0);
}

function resolve_video_path($url) {
    if (!$url) return false;
    // Decodificar la URL para obtener la ruta física real
    $rawPath = rawurldecode($url);
    
    // Eliminar prefijo de la API si existe (api/uploads/...)
    $cleanPath = $rawPath;
    if (strpos($rawPath, 'api/') === 0) {
        $cleanPath = substr($rawPath, 4);
    }

    // Prioridad 1: Verificar ruta absoluta (NAS/Local) o relativa directa
    if (file_exists($cleanPath)) return realpath($cleanPath);
    if (file_exists($rawPath)) return realpath($rawPath);
    
    // Prioridad 2: Buscar en la carpeta de uploads de la API
    $apiUploads = dirname(__DIR__) . DIRECTORY_SEPARATOR . $cleanPath;
    if (file_exists($apiUploads)) return $apiUploads;

    return false;
}

function check_needs_transcode($filePath) {
    if (filter_var($filePath, FILTER_VALIDATE_URL)) return false;
    
    $realPath = resolve_video_path($filePath);
    if (!$realPath || !is_readable($realPath)) return false;

    $ext = strtolower(pathinfo($realPath, PATHINFO_EXTENSION));
    
    // Si no es mp4 o webm, forzar transcodificación para compatibilidad PWA
    if (!in_array($ext, ['mp4', 'webm'])) return true;

    if (!check_ffmpeg_available()) return false;

    $isWin = strtoupper(substr(PHP_OS, 0, 3)) === 'WIN';
    $ffprobe = $isWin ? 'ffprobe.exe' : 'ffprobe';
    
    // Obtener el códec de video
    $cmd = "$ffprobe -v error -select_streams v:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 " . safe_shell_arg($realPath);
    @exec($cmd, $output, $resultCode);
    $codec = isset($output[0]) ? trim($output[0]) : '';
    
    // Si no es h264, necesita transcodificación
    return ($codec !== 'h264' && !empty($codec));
}

function admin_transcode_batch($pdo) {
    // Asegurar que no haya nada en el buffer que rompa el JSON
    while (ob_get_level()) ob_end_clean();
    ob_start();

    set_time_limit(0);
    ini_set('memory_limit', '1024M');

    if (!check_ffmpeg_available()) {
        respond(false, null, "FFmpeg no instalado o exec() deshabilitado.");
    }

    try {
        $settings = $pdo->query("SELECT transcodePreset FROM system_settings WHERE id = 1")->fetch(PDO::FETCH_ASSOC);
        $preset = $settings['transcodePreset'] ?? 'superfast';
        $limit = isset($_GET['limit']) ? intval($_GET['limit']) : 1;

        $stmt = $pdo->prepare("SELECT id, videoUrl FROM videos WHERE transcode_status = 'WAITING' LIMIT ?");
        $stmt->execute([$limit]);
        $queue = $stmt->fetchAll(PDO::FETCH_ASSOC);
        
        if (empty($queue)) {
            respond(true, ['processed' => 0, 'completed' => true, 'remaining' => 0]);
        }

        $processedCount = 0;
        foreach ($queue as $v) {
            $path = resolve_video_path($v['videoUrl']);
            
            if (!$path) {
                $pdo->prepare("UPDATE videos SET transcode_status = 'FAILED' WHERE id = ?")->execute([$v['id']]);
                continue;
            }

            // Marcar como en proceso para evitar duplicidad
            $pdo->prepare("UPDATE videos SET transcode_status = 'PROCESSING' WHERE id = ?")->execute([$v['id']]);
            
            $dir = dirname($path);
            $filename = pathinfo($path, PATHINFO_FILENAME);
            $tempOut = $dir . DIRECTORY_SEPARATOR . 'tr_' . uniqid() . '.mp4';
            
            // Comando FFmpeg reforzado
            $cmd = "ffmpeg -loglevel error -y -i " . safe_shell_arg($path) . " -c:v libx264 -preset $preset -crf 23 -profile:v high -level 4.1 -c:a aac -b:a 128k -movflags +faststart " . safe_shell_arg($tempOut);
            
            $outputArr = [];
            $resultCode = -1;
            @exec($cmd, $outputArr, $resultCode);

            if ($resultCode === 0 && file_exists($tempOut) && filesize($tempOut) > 0) {
                // Determinar el nombre final
                $finalPath = $dir . DIRECTORY_SEPARATOR . $filename . '.mp4';
                
                // Si el archivo original era otro formato (mkv, avi), lo borramos para ahorrar espacio
                if (strtolower(pathinfo($path, PATHINFO_EXTENSION)) !== 'mp4') {
                     if (strpos($path, 'uploads') !== false) @unlink($path);
                } else if ($path !== $finalPath) {
                    // Si ya existía un mp4 con ese nombre pero incompatible
                     @unlink($path);
                }

                @rename($tempOut, $finalPath);
                
                // Normalizar URL para base de datos
                $newUrl = str_replace('\\', '/', $finalPath);
                if (strpos($newUrl, 'uploads/') !== false && strpos($newUrl, 'api/') === false) {
                    $newUrl = 'api/' . $newUrl;
                }
                
                $pdo->prepare("UPDATE videos SET videoUrl = ?, transcode_status = 'DONE', needs_transcode = 0 WHERE id = ?")
                    ->execute([$newUrl, $v['id']]);
                $processedCount++;
            } else {
                // Si falló, marcamos como fallido para no reintentar infinitamente
                $pdo->prepare("UPDATE videos SET transcode_status = 'FAILED' WHERE id = ?")->execute([$v['id']]);
                if (file_exists($tempOut)) @unlink($tempOut);
            }
        }

        $remaining = $pdo->query("SELECT COUNT(*) FROM videos WHERE transcode_status = 'WAITING'")->fetchColumn();
        
        // Respuesta final limpia
        respond(true, [
            'processed' => $processedCount, 
            'remaining' => (int)$remaining, 
            'completed' => ($remaining == 0)
        ]);

    } catch (Exception $e) {
        respond(false, null, "Error interno en el motor: " . $e->getMessage());
    }
}

function admin_scan_incompatible($pdo, $input) {
    while (ob_get_level()) ob_end_clean();
    ob_start();

    if (!check_ffmpeg_available()) {
        respond(false, null, "FFmpeg no disponible.");
    }

    $days = isset($input['days']) ? intval($input['days']) : 0;
    $source = $input['source'] ?? 'ALL';
    $onlyNonMp4 = isset($input['onlyNonMp4']) ? (bool)$input['onlyNonMp4'] : false;

    // Buscamos videos que NO tengan un estado de éxito o espera
    $where = ["(transcode_status NOT IN ('WAITING', 'PROCESSING', 'DONE') OR transcode_status IS NULL)"];
    $params = [];

    if ($days > 0) {
        $where[] = "createdAt > ?";
        $params[] = time() - ($days * 86400);
    }
    
    if ($source === 'LOCAL') $where[] = "isLocal = 1";
    else if ($source === 'SERVER') $where[] = "isLocal = 0";

    if ($onlyNonMp4) {
        $where[] = "(videoUrl NOT LIKE '%.mp4' AND videoUrl NOT LIKE '%.MP4')";
    }

    $sql = "SELECT id, videoUrl FROM videos WHERE " . implode(' AND ', $where);
    
    try {
        $stmt = $pdo->prepare($sql);
        $stmt->execute($params);
        $videos = $stmt->fetchAll(PDO::FETCH_ASSOC);
        
        $markedCount = 0;
        foreach ($videos as $v) {
            if (check_needs_transcode($v['videoUrl'])) {
                $pdo->prepare("UPDATE videos SET needs_transcode = 1, transcode_status = 'WAITING' WHERE id = ?")
                    ->execute([$v['id']]);
                $markedCount++;
            } else {
                // Si el archivo ya es compatible, lo marcamos como DONE para optimizar futuros escaneos
                $pdo->prepare("UPDATE videos SET transcode_status = 'DONE', needs_transcode = 0 WHERE id = ?")
                    ->execute([$v['id']]);
            }
        }
        respond(true, ['marked' => $markedCount, 'scanned' => count($videos)]);
    } catch (Exception $e) { respond(false, null, $e->getMessage()); }
}

function admin_add_balance($adminId, $targetId, $amount) {
    global $pdo;
    if (!$targetId || !$amount) respond(false, null, "Faltan datos.");
    $pdo->beginTransaction();
    try {
        $pdo->prepare("UPDATE users SET balance = balance + ? WHERE id = ?")->execute([$amount, $targetId]);
        $tid = uniqid('tx_man_');
        $pdo->prepare("INSERT INTO transactions (id, buyerId, amount, timestamp, type) VALUES (?, ?, ?, ?, 'DEPOSIT')")
            ->execute([$tid, $targetId, $amount, time()]);
        $pdo->commit();
        respond(true);
    } catch (Exception $e) { $pdo->rollBack(); respond(false, null, $e->getMessage()); }
}

function admin_get_local_stats($pdo) {
    try {
        $path = $pdo->query("SELECT localLibraryPath FROM system_settings WHERE id = 1")->fetchColumn() ?: '';
        $stats = [
            'path' => $path, 
            'disk_total' => 0, 
            'disk_free' => 0, 
            'db_videos' => $pdo->query("SELECT COUNT(*) FROM videos WHERE isLocal = 1")->fetchColumn(), 
            'ffmpeg_available' => check_ffmpeg_available()
        ];
        if ($path && is_dir($path)) {
            $stats['disk_total'] = round(disk_total_space($path) / 1073741824, 2);
            $stats['disk_free'] = round(disk_free_space($path) / 1073741824, 2);
        }
        respond(true, $stats);
    } catch (Exception $e) { respond(false, null, $e->getMessage()); }
}

function admin_get_real_stats($pdo) {
    try {
        respond(true, [
            'userCount' => $pdo->query("SELECT COUNT(*) FROM users")->fetchColumn(),
            'videoCount' => $pdo->query("SELECT COUNT(*) FROM videos WHERE category NOT IN ('PENDING', 'PROCESSING')")->fetchColumn(),
            'adminVideoSales' => $pdo->query("SELECT COUNT(*) FROM transactions WHERE type='PURCHASE' AND creatorId IN (SELECT id FROM users WHERE role='ADMIN')")->fetchColumn(),
            'avgDeposit' => $pdo->query("SELECT AVG(amount) FROM balance_requests WHERE status='APPROVED'")->fetchColumn() ?: 0
        ]);
    } catch (Exception $e) { respond(false, null, $e->getMessage()); }
}

function admin_cleanup_system_files($pdo) {
    set_time_limit(0);
    $deletedVideos = 0; $deletedThumbs = 0;
    $files = glob('uploads/videos/*');
    foreach ($files as $file) {
        $url = 'api/' . $file;
        $stmt = $pdo->prepare("SELECT COUNT(*) FROM videos WHERE videoUrl = ?");
        $stmt->execute([$url]);
        if ($stmt->fetchColumn() == 0) { @unlink($file); $deletedVideos++; }
    }
    respond(true, ['videos' => $deletedVideos, 'thumbnails' => $deletedThumbs]);
}

function admin_repair_db($pdo) {
    try {
        require_once 'functions_schema.php';
        foreach (getAppSchema() as $table => $def) { syncTable($pdo, $table, $def); }
        respond(true);
    } catch (Exception $e) { respond(false, null, $e->getMessage()); }
}

function admin_handle_balance_request($pdo, $input) {
    $reqId = $input['requestId']; $action = $input['action'];
    if ($action === 'APPROVED') {
        $pdo->beginTransaction();
        try {
            $stmt = $pdo->prepare("SELECT * FROM balance_requests WHERE id = ? AND status = 'PENDING' FOR UPDATE");
            $stmt->execute([$reqId]);
            $req = $stmt->fetch();
            if ($req) {
                $pdo->prepare("UPDATE users SET balance = balance + ? WHERE id = ?")->execute([$req['amount'], $req['userId']]);
                $pdo->prepare("UPDATE balance_requests SET status = 'APPROVED' WHERE id = ?")->execute([$reqId]);
            }
            $pdo->commit();
        } catch (Exception $e) { $pdo->rollBack(); respond(false, null, $e->getMessage()); }
    } else $pdo->prepare("UPDATE balance_requests SET status = 'REJECTED' WHERE id = ?")->execute([$reqId]);
    respond(true);
}

function admin_handle_vip_request($pdo, $input) {
    $reqId = $input['requestId']; $action = $input['action'];
    if ($action === 'APPROVED') {
        $stmt = $pdo->prepare("SELECT * FROM vip_requests WHERE id = ?");
        $stmt->execute([$reqId]);
        $req = $stmt->fetch();
        if ($req) {
            $plan = json_decode($req['planSnapshot'], true); $userId = $req['userId'];
            if ($plan['type'] === 'ACCESS') {
                $expiry = time() + ($plan['durationDays'] * 86400);
                $pdo->prepare("UPDATE users SET vipExpiry = ? WHERE id = ?")->execute([$expiry, $userId]);
            } else {
                $amount = $plan['price'] * (1 + ($plan['bonusPercent']/100));
                $pdo->prepare("UPDATE users SET balance = balance + ? WHERE id = ?")->execute([$amount, $userId]);
            }
            $pdo->prepare("UPDATE vip_requests SET status = 'APPROVED' WHERE id = ?")->execute([$reqId]);
        }
    } else $pdo->prepare("UPDATE vip_requests SET status = 'REJECTED' WHERE id = ?")->execute([$reqId]);
    respond(true);
}

function admin_get_global_transactions($pdo) {
    $stmt = $pdo->query("SELECT t.*, u.username as buyerName FROM transactions t LEFT JOIN users u ON t.buyerId = u.id ORDER BY t.timestamp DESC LIMIT 100");
    respond(true, ['history' => $stmt->fetchAll(), 'systemRevenue' => floatval($pdo->query("SELECT SUM(adminFee) FROM transactions")->fetchColumn())]);
}

function admin_get_balance_requests($pdo) {
    $balance = $pdo->query("SELECT r.*, u.username FROM balance_requests r JOIN users u ON r.userId = u.id WHERE r.status = 'PENDING'")->fetchAll();
    $vip = $pdo->query("SELECT r.*, u.username FROM vip_requests r JOIN users u ON r.userId = u.id WHERE r.status = 'PENDING'")->fetchAll();
    $activeVip = $pdo->query("SELECT id, username, avatarUrl, vipExpiry FROM users WHERE vipExpiry > UNIX_TIMESTAMP()")->fetchAll();
    respond(true, ['balance' => $balance, 'vip' => $vip, 'activeVip' => $activeVip]);
}

// Stubs
function admin_smart_cleaner_preview($pdo, $input) { respond(true, ['preview' => [], 'stats' => ['totalVideos'=>0, 'videosToDelete'=>0, 'spaceReclaimed'=>'0 B']]); }
function admin_smart_cleaner_execute($pdo, $input) { respond(true, ['deleted' => 0]); }
function admin_file_cleanup_preview($pdo, $input) { respond(true, []); }
function admin_file_cleanup_execute($pdo, $input) { respond(true, ['deleted' => 0]); }
function admin_organize_paquete($pdo, $input) { respond(true, ['moved' => 0, 'cleaned' => 0]); }
function admin_search_external($pdo, $input) { respond(true, []); }
function admin_server_import_video($pdo, $input) { respond(true); }
function admin_get_requests($pdo, $status) { respond(true, []); }
function user_request_content($pdo, $input) { respond(true); }
function admin_update_request_status($pdo, $input) { respond(true); }
function admin_delete_request($pdo, $input) { respond(true); }

?>