
<?php

function admin_get_settings($pdo) {
    $pdo->exec("INSERT IGNORE INTO system_settings (id) VALUES (1)");
    $stmt = $pdo->query("SELECT * FROM system_settings WHERE id = 1");
    $settings = $stmt->fetch();
    if ($settings) {
        $settings['categoryPrices'] = json_decode($settings['categoryPrices'] ?? '{}', true);
        if (empty($settings['categoryPrices'])) $settings['categoryPrices'] = (object)[];
        $settings['customCategories'] = json_decode($settings['customCategories'] ?? '[]', true);
        $settings['ftpSettings'] = json_decode($settings['ftpSettings'] ?? 'null', true);
        $settings['vipPlans'] = json_decode($settings['vipPlans'] ?? '[]', true);
        $settings['paqueteMapper'] = json_decode($settings['paqueteMapper'] ?? '{}', true);
        if (empty($settings['paqueteMapper'])) $settings['paqueteMapper'] = (object)[];
        $settings['enableDebugLog'] = (bool)($settings['enableDebugLog'] ?? true);
        $settings['autoTranscode'] = (bool)($settings['autoTranscode'] ?? false);
        $settings['is_transcoder_active'] = (bool)($settings['is_transcoder_active'] ?? false);
        $settings['enableYoutube'] = (bool)($settings['enableYoutube'] ?? false);
        $settings['isQueuePaused'] = (bool)($settings['isQueuePaused'] ?? false);
        respond(true, $settings);
    }
    respond(false, null, 'Settings not found');
}

function admin_update_settings($pdo, $input) {
    $s = $input['settings'] ?? [];
    if (empty($s)) respond(true);
    $pdo->exec("INSERT IGNORE INTO system_settings (id) VALUES (1)");
    $map = [
        'downloadStartTime' => 'downloadStartTime', 'downloadEndTime' => 'downloadEndTime', 
        'isQueuePaused' => 'isQueuePaused', 'batchSize' => 'batchSize', 
        'maxDuration' => 'maxDuration', 'maxResolution' => 'maxResolution', 
        'pexelsKey' => 'pexelsKey', 'pixabayKey' => 'pixabayKey', 
        'geminiKey' => 'geminiKey', 'ytDlpPath' => 'ytDlpPath', 
        'enableYoutube' => 'enableYoutube', 'autoTranscode' => 'autoTranscode', 
        'is_transcoder_active' => 'is_transcoder_active', 'transcodePreset' => 'transcodePreset', 
        'categoryPrices' => 'categoryPrices', 'customCategories' => 'customCategories', 
        'localLibraryPath' => 'localLibraryPath', 'ftpSettings' => 'ftpSettings', 
        'videoCommission' => 'videoCommission', 'marketCommission' => 'marketCommission', 
        'vipPlans' => 'vipPlans', 'paymentInstructions' => 'paymentInstructions', 
        'paqueteMapper' => 'paqueteMapper', 'tropipayClientId' => 'tropipayClientId', 
        'tropipayClientSecret' => 'tropipayClientSecret', 'currencyConversion' => 'currencyConversion', 
        'proxyUrl' => 'proxyUrl', 'enableDebugLog' => 'enableDebugLog'
    ];
    $fields = []; $params = [];
    foreach ($map as $key => $col) {
        if (array_key_exists($key, $s)) {
            $val = $s[$key];
            if (is_array($val) || is_object($val)) $val = json_encode($val, JSON_UNESCAPED_UNICODE);
            else if (is_bool($val)) $val = $val ? 1 : 0;
            $fields[] = "$col = ?";
            $params[] = $val;
        }
    }
    if (empty($fields)) respond(true);
    try {
        $sql = "UPDATE system_settings SET " . implode(', ', $fields) . " WHERE id = 1";
        $stmt = $pdo->prepare($sql);
        $stmt->execute($params);
        respond(true);
    } catch (Exception $e) {
        respond(false, null, "Error SQL: " . $e->getMessage());
    }
}

function admin_get_transcode_profiles($pdo) {
    $stmt = $pdo->query("SELECT * FROM transcode_profiles ORDER BY extension ASC");
    respond(true, $stmt->fetchAll(PDO::FETCH_ASSOC));
}

function admin_save_transcode_profile($pdo, $input) {
    $ext = strtolower(trim($input['extension'], '. '));
    $args = $input['command_args'];
    $desc = $input['description'] ?? '';
    $stmt = $pdo->prepare("REPLACE INTO transcode_profiles (extension, command_args, description) VALUES (?, ?, ?)");
    $stmt->execute([$ext, $args, $desc]);
    respond(true);
}

function admin_delete_transcode_profile($pdo, $input) {
    $ext = $input['extension'];
    $pdo->prepare("DELETE FROM transcode_profiles WHERE extension = ?")->execute([$ext]);
    respond(true);
}

function admin_remove_from_queue($pdo, $input) {
    $id = $input['videoId'];
    $pdo->prepare("UPDATE videos SET transcode_status = 'NONE' WHERE id = ?")->execute([$id]);
    respond(true);
}

function admin_clear_transcode_queue($pdo) {
    $pdo->exec("UPDATE videos SET transcode_status = 'NONE' WHERE transcode_status IN ('WAITING', 'FAILED')");
    respond(true);
}

function admin_retry_failed_transcodes($pdo) {
    $pdo->exec("UPDATE videos SET transcode_status = 'WAITING' WHERE transcode_status = 'FAILED'");
    respond(true);
}

function admin_cleanup_stale_transcodes($pdo) {
    $now = time();
    $gracePeriod = 300; // 5 minutos de inactividad
    $stmt = $pdo->query("SELECT id, videoUrl, title, createdAt FROM videos WHERE transcode_status = 'PROCESSING'");
    $processingInDb = $stmt->fetchAll(PDO::FETCH_ASSOC);
    
    foreach ($processingInDb as $v) {
        $marker = "SP_JOB_ID_" . $v['id'];
        // Detectar si el proceso sigue vivo en el SO (Linux)
        $pid = shell_exec("pgrep -f " . escapeshellarg($marker));
        
        if (empty(trim($pid))) {
            $sourcePath = resolve_video_path($v['videoUrl']);
            $tempPath = $sourcePath . ".transcoding.mp4";
            
            // Si el archivo temporal existe pero el proceso murió, limpiar
            if (file_exists($tempPath)) {
                $fileTime = filemtime($tempPath);
                if (($now - $fileTime) > 60) { // Si el archivo no ha cambiado en 1 min
                    @unlink($tempPath);
                    $pdo->prepare("UPDATE videos SET transcode_status = 'FAILED', reason = 'Proceso interrumpido inesperadamente' WHERE id = ?")->execute([$v['id']]);
                }
            } else {
                $pdo->prepare("UPDATE videos SET transcode_status = 'WAITING' WHERE id = ?")->execute([$v['id']]);
            }
        }
    }
}

function admin_transcode_batch($pdo) {
    if (session_id()) session_write_close();
    
    // Primero limpiamos los que se hayan quedado colgados
    admin_cleanup_stale_transcodes($pdo);
    
    $stmtS = $pdo->query("SELECT batchSize, transcodePreset FROM system_settings WHERE id = 1");
    $settings = $stmtS->fetch(PDO::FETCH_ASSOC);
    $limit = isset($settings['batchSize']) ? (int)$settings['batchSize'] : 1;
    
    // Contar cuántos procesos SP_JOB_ID están activos realmente
    $osPids = shell_exec("pgrep -f \"SP_JOB_ID_\"");
    $osCount = !empty(trim($osPids)) ? count(explode("\n", trim($osPids))) : 0;
    
    if ($osCount >= $limit) {
        respond(true, ['processed' => 0, 'message' => 'Límite de procesos alcanzado', 'active_jobs' => $osCount]);
    }
    
    // Obtener el siguiente video en cola
    $stmt = $pdo->query("SELECT id, videoUrl, title FROM videos WHERE transcode_status = 'WAITING' LIMIT 1");
    $video = $stmt->fetch(PDO::FETCH_ASSOC);
    
    if (!$video) respond(true, ['processed' => 0, 'completed' => true]);
    
    $sourcePath = resolve_video_path($video['videoUrl']);
    if (!$sourcePath || !file_exists($sourcePath)) {
        $pdo->prepare("UPDATE videos SET transcode_status = 'FAILED', reason = 'Archivo de origen no encontrado' WHERE id = ?")->execute([$video['id']]);
        respond(false, null, "Archivo perdido: " . $video['title']);
    }
    
    $ext = strtolower(pathinfo($sourcePath, PATHINFO_EXTENSION));
    $stmtP = $pdo->prepare("SELECT command_args FROM transcode_profiles WHERE extension = ?");
    $stmtP->execute([$ext]);
    $profileArgs = $stmtP->fetchColumn();
    
    if (!$profileArgs) {
        $preset = $settings['transcodePreset'] ?? 'ultrafast';
        $profileArgs = "-c:v libx264 -preset $preset -crf 23 -c:a aac -b:a 128k -movflags +faststart";
    }
    
    $tempPath = $sourcePath . ".transcoding.mp4";
    if (file_exists($tempPath)) @unlink($tempPath);
    
    $marker = "SP_JOB_ID_" . $video['id'];
    // Comando robusto con Niced priority (prioridad de CPU baja para no colgar el NAS)
    $cmd = "nice -n 15 ffmpeg -y -i " . escapeshellarg($sourcePath) . " $profileArgs -user_agent " . escapeshellarg($marker) . " " . escapeshellarg($tempPath);
    $fullCmd = "nohup $cmd > /dev/null 2>&1 &";
    
    shell_exec($fullCmd);
    $pdo->prepare("UPDATE videos SET transcode_status = 'PROCESSING', createdAt = ? WHERE id = ?")->execute([time(), $video['id']]);
    
    respond(true, ['processed' => 1, 'message' => 'Tarea lanzada', 'videoId' => $video['id']]);
}

function admin_transcode_scan_filters($pdo, $input) {
    $days = intval($input['days'] ?? 0);
    $onlyNonMp4 = isset($input['onlyNonMp4']) && $input['onlyNonMp4'];
    $onlyIncompatible = isset($input['onlyIncompatible']) && $input['onlyIncompatible'];
    $mode = $input['mode'] ?? 'PREVIEW'; 
    $where = ["transcode_status = 'NONE'"];
    $params = [];
    if ($days > 0) {
        $threshold = time() - ($days * 86400);
        $where[] = "createdAt < ?";
        $params[] = $threshold;
    }
    if ($onlyNonMp4) {
        $where[] = "(videoUrl NOT LIKE '%.mp4' AND videoUrl NOT LIKE '%action=stream%')";
    }
    if ($onlyIncompatible) {
        $where[] = "needs_transcode = 1";
    }
    $sqlWhere = implode(' AND ', $where);
    if ($mode === 'PREVIEW') {
        $stmt = $pdo->prepare("SELECT COUNT(*) FROM videos WHERE $sqlWhere");
        $stmt->execute($params);
        respond(true, ['count' => (int)$stmt->fetchColumn()]);
    } else {
        $stmt = $pdo->prepare("UPDATE videos SET transcode_status = 'WAITING' WHERE $sqlWhere");
        $stmt->execute($params);
        respond(true, ['affected' => $stmt->rowCount()]);
    }
}
// Resto de funciones omitidas por brevedad...
