<?php

function admin_get_settings($pdo) {
    $stmt = $pdo->query("SELECT * FROM system_settings WHERE id = 1");
    $settings = $stmt->fetch();
    if ($settings) {
        $settings['categoryPrices'] = json_decode($settings['categoryPrices'] ?? '{}', true);
        $settings['customCategories'] = json_decode($settings['customCategories'] ?? '[]', true);
        $settings['ftpSettings'] = json_decode($settings['ftpSettings'] ?? 'null', true);
        $settings['vipPlans'] = json_decode($settings['vipPlans'] ?? '[]', true);
        $settings['paqueteMapper'] = json_decode($settings['paqueteMapper'] ?? '{}', true);
        respond(true, $settings);
    }
    respond(false, null, 'Settings not found');
}

function admin_update_settings($pdo, $input) {
    $s = $input['settings'] ?? [];
    if (empty($s)) respond(true);
    $map = [
        'downloadStartTime' => 'downloadStartTime', 
        'downloadEndTime' => 'downloadEndTime', 
        'isQueuePaused' => 'isQueuePaused', 
        'batchSize' => 'batchSize', 
        'maxDuration' => 'maxDuration', 
        'maxResolution' => 'maxResolution', 
        'pexelsKey' => 'pexelsKey', 
        'pixabayKey' => 'pixabayKey', 
        'geminiKey' => 'geminiKey', 
        'ytDlpPath' => 'ytDlpPath', 
        'enableYoutube' => 'enableYoutube', 
        'autoTranscode' => 'autoTranscode', 
        'is_transcoder_active' => 'is_transcoder_active', 
        'transcodePreset' => 'transcodePreset', 
        'categoryPrices' => 'categoryPrices', 
        'customCategories' => 'customCategories', 
        'localLibraryPath' => 'localLibraryPath', 
        'ftpSettings' => 'ftpSettings', 
        'videoCommission' => 'videoCommission', 
        'marketCommission' => 'marketCommission', 
        'vipPlans' => 'vipPlans', 
        'paymentInstructions' => 'paymentInstructions', 
        'paqueteMapper' => 'paqueteMapper', 
        'tropipayClientId' => 'tropipayClientId', 
        'tropipayClientSecret' => 'tropipayClientSecret', 
        'currencyConversion' => 'currencyConversion', 
        'proxyUrl' => 'proxyUrl',
        'enableDebugLog' => 'enableDebugLog'
    ];
    $fields = []; $params = [];
    foreach ($map as $key => $col) {
        if (array_key_exists($key, $s)) {
            $fields[] = "$col = ?"; $val = $s[$key];
            if (is_array($val)) $val = json_encode($val, JSON_UNESCAPED_UNICODE);
            else if (is_bool($val)) $val = $val ? 1 : 0;
            $params[] = $val;
        }
    }
    if (empty($fields)) respond(true);
    $sql = "UPDATE system_settings SET " . implode(', ', $fields) . " WHERE id = 1";
    $pdo->prepare($sql)->execute($params);
    respond(true);
}

function admin_repair_db($pdo) {
    require_once 'functions_schema.php';
    $schema = getAppSchema();
    foreach ($schema as $tableName => $def) {
        syncTable($pdo, $tableName, $def);
    }
    respond(true, ['message' => 'Base de datos sincronizada']);
}

function admin_cleanup_stale_transcodes($pdo) {
    // Si un video lleva más de 4 horas en PROCESSING, lo devolvemos a espera
    $staleTime = time() - 14400;
    $pdo->prepare("UPDATE videos SET transcode_status = 'WAITING' WHERE transcode_status = 'PROCESSING' AND createdAt < ?")
        ->execute([$staleTime]);
}

function admin_transcode_batch($pdo) {
    set_time_limit(0); 
    admin_cleanup_stale_transcodes($pdo);

    // 1. Verificar si ffmpeg está disponible
    exec("which ffmpeg", $ffmpegPath, $ffmpegCode);
    if ($ffmpegCode !== 0) {
        file_debug_log("ERROR CRÍTICO", "ffmpeg no encontrado.");
        respond(false, null, "FFmpeg no instalado.");
    }

    // 2. Buscar video en espera (WAITING)
    $stmt = $pdo->query("SELECT id, videoUrl, title FROM videos WHERE transcode_status = 'WAITING' LIMIT 1");
    $video = $stmt->fetch(PDO::FETCH_ASSOC);

    if (!$video) {
        respond(true, ['processed' => 0, 'completed' => true]);
    }

    // 3. Resolver ruta física
    $sourcePath = resolve_video_path($video['videoUrl']);
    if (!$sourcePath || !file_exists($sourcePath)) {
        $pdo->prepare("UPDATE videos SET transcode_status = 'FAILED', reason = 'Archivo no encontrado fisicamente' WHERE id = ?")->execute([$video['id']]);
        respond(false, null, "Archivo no encontrado: " . $video['videoUrl']);
    }

    // 4. Marcar inicio real
    $pdo->prepare("UPDATE videos SET transcode_status = 'PROCESSING', createdAt = ? WHERE id = ?")
        ->execute([time(), $video['id']]);

    // Usar extensión .mp4.tmp para que FFmpeg sepa que el contenedor es MP4
    $tempPath = $sourcePath . ".transcoded.mp4.tmp";
    if (file_exists($tempPath)) @unlink($tempPath);

    $preset = 'ultrafast';
    $stmtS = $pdo->query("SELECT transcodePreset FROM system_settings WHERE id = 1");
    $dbPreset = $stmtS->fetchColumn();
    if ($dbPreset) $preset = $dbPreset;

    /**
     * COMANDO MEJORADO:
     * -f mp4: Fuerza el formato de salida a MP4 independientemente de la extensión.
     * -movflags +faststart: Optimiza para reproducción web (PWA).
     * -threads 0: Usa todo el CPU disponible.
     * -pix_fmt yuv420p: Asegura compatibilidad con navegadores antiguos.
     */
    $cmd = "ffmpeg -y -threads 0 -i " . escapeshellarg($sourcePath) . " -c:v libx264 -preset $preset -crf 23 -pix_fmt yuv420p -c:a aac -b:a 128k -ac 2 -movflags +faststart -f mp4 " . escapeshellarg($tempPath) . " 2>&1";
    
    file_debug_log("EJECUTANDO FFMPEG", ["video" => $video['title'], "cmd" => $cmd]);
    
    $output = [];
    $resultCode = -1;
    exec($cmd, $output, $resultCode);

    if ($resultCode === 0 && file_exists($tempPath) && filesize($tempPath) > 0) {
        $backupPath = $sourcePath . ".old";
        // Si el archivo original no es .mp4, querremos que el nuevo archivo sí lo sea en la base de datos
        // Pero para no romper rutas del NAS, mantenemos el nombre original pero con contenido MP4
        if (@rename($sourcePath, $backupPath)) {
            if (@rename($tempPath, $sourcePath)) {
                @unlink($backupPath);
                $pdo->prepare("UPDATE videos SET transcode_status = 'DONE', reason = NULL WHERE id = ?")->execute([$video['id']]);
                file_debug_log("CONVERSIÓN EXITOSA", $video['title']);
                respond(true, ['processed' => 1, 'completed' => false, 'videoId' => $video['id']]);
            } else {
                @rename($backupPath, $sourcePath); 
            }
        }
    }

    // Manejo de Error real
    if (file_exists($tempPath)) @unlink($tempPath);
    
    // Capturar el error real de la salida de FFmpeg para el admin
    $lastLine = count($output) > 0 ? end($output) : "Unknown Error";
    $errorMsg = "FFmpeg Code $resultCode: $lastLine";
    
    $pdo->prepare("UPDATE videos SET transcode_status = 'FAILED', reason = ? WHERE id = ?")
        ->execute([$errorMsg, $video['id']]);
        
    file_debug_log("CONVERSIÓN FALLIDA", [
        "video" => $video['title'], 
        "result" => $resultCode,
        "error" => $lastLine
    ]);
    
    respond(false, null, "Error en conversión: " . $errorMsg);
}

function admin_get_local_stats($pdo) {
    $videosDir = 'uploads/videos/';
    $totalSpace = @disk_total_space(".") ?: 0;
    $freeSpace = @disk_free_space(".") ?: 0;
    
    $dbVideos = $pdo->query("SELECT COUNT(*) FROM videos")->fetchColumn();
    
    $orphanCount = 0;
    if (is_dir($videosDir)) {
        $files = scandir($videosDir);
        foreach ($files as $f) {
            if ($f === '.' || $f === '..') continue;
            $path = 'api/' . $videosDir . $f;
            $stmt = $pdo->prepare("SELECT COUNT(*) FROM videos WHERE videoUrl = ?");
            $stmt->execute([$path]);
            if ($stmt->fetchColumn() == 0) $orphanCount++;
        }
    }

    respond(true, [
        'disk_total' => round($totalSpace / (1024*1024*1024), 2),
        'disk_free' => round($freeSpace / (1024*1024*1024), 2),
        'db_videos' => (int)$dbVideos,
        'orphan_files' => $orphanCount,
        'broken_links' => 0
    ]);
}

function admin_cleanup_system_files($pdo) {
    $videosDir = 'uploads/videos/';
    $thumbsDir = 'uploads/thumbnails/';
    $deletedVideos = 0;
    $deletedThumbs = 0;

    $ignore = ['.', '..', '@eaDir', '#recycle', '.DS_Store'];

    if (is_dir($videosDir)) {
        $files = scandir($videosDir);
        foreach ($files as $f) {
            if (in_array($f, $ignore)) continue;
            
            if (strpos($f, '.tmp') !== false || strpos($f, '_transcoding') !== false) {
                if (@unlink($videosDir . $f)) $deletedVideos++;
                continue;
            }

            $fullPath = $videosDir . $f;
            if (is_dir($fullPath)) continue;

            $relPath = 'api/' . $fullPath;
            $stmt = $pdo->prepare("SELECT COUNT(*) FROM videos WHERE videoUrl = ?");
            $stmt->execute([$relPath]);
            if ($stmt->fetchColumn() == 0) {
                if (@unlink($fullPath)) $deletedVideos++;
            }
        }
    }

    if (is_dir($thumbsDir)) {
        $files = scandir($thumbsDir);
        foreach ($files as $f) {
            if (in_array($f, $ignore) || $f === 'default.jpg') continue;
            $fullPath = $thumbsDir . $f;
            if (is_dir($fullPath)) continue;

            $relPath = 'api/' . $fullPath;
            $stmt = $pdo->prepare("SELECT COUNT(*) FROM videos WHERE thumbnailUrl = ?");
            $stmt->execute([$relPath]);
            if ($stmt->fetchColumn() == 0) {
                if (@unlink($fullPath)) $deletedThumbs++;
            }
        }
    }

    respond(true, ['videos' => $deletedVideos, 'thumbnails' => $deletedThumbs]);
}

function admin_add_balance($pdo, $input) {
    $adminId = $input['adminId'];
    $targetId = $input['targetId'];
    $amount = floatval($input['amount']);

    if ($amount <= 0) respond(false, null, 'Monto inválido');

    $pdo->beginTransaction();
    try {
        $pdo->prepare("UPDATE users SET balance = balance + ? WHERE id = ?")->execute([$amount, $targetId]);
        $tid = uniqid('tx_adm_');
        $pdo->prepare("INSERT INTO transactions (id, buyerId, creatorId, videoId, amount, timestamp, type) VALUES (?, ?, NULL, NULL, ?, ?, 'DEPOSIT')")
            ->execute([tid, $targetId, $amount, time()]);
        $pdo->commit();
        respond(true);
    } catch (Exception $e) {
        $pdo->rollBack();
        respond(false, null, $e->getMessage());
    }
}

function admin_get_balance_requests($pdo) {
    $stmt = $pdo->query("SELECT b.*, u.username FROM balance_requests b JOIN users u ON b.userId = u.id WHERE b.status = 'PENDING' ORDER BY b.createdAt DESC");
    $bal = $stmt->fetchAll(PDO::FETCH_ASSOC);
    $stmt = $pdo->query("SELECT v.*, u.username FROM vip_requests v JOIN users u ON v.userId = u.id WHERE v.status = 'PENDING' ORDER BY v.createdAt DESC");
    $vip = $stmt->fetchAll(PDO::FETCH_ASSOC);
    respond(true, ['balance' => $bal, 'vip' => $vip]);
}

function admin_get_global_transactions($pdo) {
    $stmt = $pdo->query("
        SELECT t.*, 
               u1.username as buyerName, 
               u2.username as sellerName,
               v.title as videoTitle,
               m.title as itemTitle
        FROM transactions t
        LEFT JOIN users u1 ON t.buyerId = u1.id
        LEFT JOIN users u2 ON t.creatorId = u2.id
        LEFT JOIN videos v ON t.videoId = v.id
        LEFT JOIN marketplace_items m ON t.marketplaceItemId = m.id
        ORDER BY t.timestamp DESC LIMIT 100
    ");
    $history = $stmt->fetchAll(PDO::FETCH_ASSOC);
    $revenue = $pdo->query("SELECT SUM(adminFee) FROM transactions")->fetchColumn() ?: 0;
    respond(true, ['history' => $history, 'systemRevenue' => (float)$revenue]);
}

function admin_get_real_stats($pdo) {
    $userCount = $pdo->query("SELECT COUNT(*) FROM users")->fetchColumn();
    $videoSales = $pdo->query("SELECT COUNT(*) FROM transactions WHERE type = 'PURCHASE'")->fetchColumn();
    $avgDeposit = $pdo->query("SELECT AVG(amount) FROM transactions WHERE type = 'DEPOSIT'")->fetchColumn() ?: 0;
    respond(true, [
        'userCount' => (int)$userCount,
        'adminVideoSales' => (int)$videoSales,
        'avgDeposit' => (float)$avgDeposit
    ]);
}

function admin_get_requests($pdo, $status) {
    $sql = "SELECT r.*, u.username FROM requests r LEFT JOIN users u ON r.userId = u.id";
    if ($status !== 'ALL') { $sql .= " WHERE r.status = " . $pdo->quote($status); }
    $sql .= " ORDER BY r.createdAt DESC";
    $stmt = $pdo->query($sql);
    respond(true, $stmt->fetchAll(PDO::FETCH_ASSOC));
}

function admin_update_request_status($pdo, $input) {
    $pdo->prepare("UPDATE requests SET status = ? WHERE id = ?")->execute([$input['status'], $input['id']]);
    respond(true);
}

function admin_delete_request($pdo, $input) {
    $pdo->prepare("DELETE FROM requests WHERE id = ?")->execute([$input['id']]);
    respond(true);
}

function admin_get_logs() {
    $logFile = __DIR__ . '/debug_log.txt';
    if (!file_exists($logFile)) respond(true, []);
    $lines = file($logFile);
    $count = count($lines);
    $start = max(0, $count - 100);
    $subset = array_slice($lines, $start);
    respond(true, array_map('trim', array_reverse($subset)));
}

function admin_clear_logs() {
    $logFile = __DIR__ . '/debug_log.txt';
    file_put_contents($logFile, "");
    respond(true);
}

function admin_stop_transcoder($pdo) {
    $pdo->exec("UPDATE system_settings SET is_transcoder_active = 0 WHERE id = 1");
    respond(true);
}

function admin_transcode_scan_filters($pdo, $input) {
    $count = $pdo->query("SELECT COUNT(*) FROM videos WHERE needs_transcode = 1")->fetchColumn();
    respond(true, ['count' => (int)$count]);
}

function admin_file_cleanup_preview($pdo, $input) { respond(true, []); }
function admin_organize_paquete($pdo, $input) { respond(true, ['plan' => []]); }
function admin_smart_cleaner_preview($pdo, $input) { respond(true, ['preview' => [], 'stats' => ['spaceReclaimed' => '0 B']]); }
function admin_smart_cleaner_execute($pdo, $input) { respond(true, ['deleted' => 0]); }
function admin_handle_balance_request($pdo, $input) { respond(true); }
function admin_handle_vip_request($pdo, $input) { respond(true); }
function admin_search_external($pdo, $input) { respond(true, []); }
function admin_server_import_video($pdo, $input) { respond(true); }
