<?php
function respond($success, $data = null, $error = null) {
    ob_clean();
    header('Content-Type: application/json');
    echo json_encode(['success' => $success, 'data' => $data, 'error' => $error]);
    exit();
}

function fix_url($url) {
    if (!empty($url) && strpos($url, 'uploads/') === 0) {
        return 'api/' . $url;
    }
    return $url;
}

function get_youtube_video($query, $config) {
    if (empty($config['enableYoutube']) || empty($config['ytDlpPath'])) return [];
    
    $bin = $config['ytDlpPath'];
    // Search 10 results, get JSON
    $cmd = "$bin \"ytsearch10:$query\" --dump-json --flat-playlist --no-warnings 2>&1";
    exec($cmd, $output, $ret);
    
    $results = [];
    foreach ($output as $line) {
        $data = json_decode($line, true);
        if ($data) {
            $results[] = [
                'id' => $data['id'],
                'source' => 'YouTube',
                'thumbnail' => "https://i.ytimg.com/vi/{$data['id']}/hqdefault.jpg",
                'title' => $data['title'],
                'duration' => $data['duration'] ?? 0,
                'downloadUrl' => "https://www.youtube.com/watch?v={$data['id']}", // Helper URL for backend import
                'author' => $data['uploader'] ?? 'Unknown'
            ];
        }
    }
    return $results;
}

function download_image($url, $path) {
    $ch = curl_init($url);
    $fp = fopen($path, 'wb');
    curl_setopt($ch, CURLOPT_FILE, $fp);
    curl_setopt($ch, CURLOPT_HEADER, 0);
    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
    curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0');
    curl_exec($ch);
    curl_close($ch);
    fclose($fp);
}

// Helper: Get Video Metadata via FFMPEG
function getVideoMetadata($file) {
    // Default
    $meta = ['duration' => 0];
    
    // Try FFProbe first (common in Linux/NAS)
    // Command to get duration in seconds
    $cmd = "ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \"$file\" 2>&1";
    $duration = shell_exec($cmd);
    
    if (is_numeric(trim($duration))) {
        $meta['duration'] = (int)$duration;
    }
    
    return $meta;
}

// Helper: Generate Thumbnail via FFMPEG
function generateVideoThumbnail($file, $outFile) {
    // Generate thumb at 10 seconds or 10%
    $cmd = "ffmpeg -y -ss 00:00:10 -i \"$file\" -vframes 1 -q:v 5 \"$outFile\" 2>&1";
    shell_exec($cmd);
    
    // Fallback to 1 sec if 10 sec failed (short video)
    if (!file_exists($outFile)) {
        $cmd = "ffmpeg -y -ss 00:00:01 -i \"$file\" -vframes 1 -q:v 5 \"$outFile\" 2>&1";
        shell_exec($cmd);
    }
    
    return file_exists($outFile);
}

// Helper: Auto Categorize
function detectCategoryFromDuration($duration) {
    if ($duration == 0) return 'OTRO'; // Unknown
    if ($duration <= 180) return 'SHORTS'; // < 3 min
    if ($duration <= 300) return 'MUSICA'; // < 5 min
    if ($duration <= 1500) return 'CORTOMETRAJE'; // < 25 min
    if ($duration <= 2700) return 'SERIES'; // < 45 min
    return 'PELICULA'; // > 45 min
}

// Helper: Get Price from Settings
function getPriceForCategory($cat, $settings) {
    $prices = json_decode($settings['categoryPrices'] ?? '{}', true);
    return isset($prices[$cat]) ? $prices[$cat] : 1; // Default 1 Saldo
}

// Helper: Smart Filename Cleaning & Parsing
function smartParseFilename($fullPath, $detectedType = null) {
    $filename = pathinfo($fullPath, PATHINFO_FILENAME);
    $folderName = basename(dirname($fullPath));
    
    // 1. Clean common "junk" from scene releases
    $junk = [
        '/1080p/i', '/720p/i', '/480p/i', '/x264/i', '/h264/i', '/x265/i', '/HEVC/i', 
        '/AAC/i', '/AC3/i', '/BluRay/i', '/WEB-DL/i', '/WEBRip/i', '/HDRip/i', 
        '/www\..+\.com/i', '/\[.*?\]/', '/\(.*?\)/'
    ];
    $cleanName = preg_replace($junk, '', $filename);
    $cleanName = str_replace(['.', '_'], ' ', $cleanName);
    
    // 2. Detect Season/Episode (S01E02, 1x02, Cap 10)
    $season = '';
    $episode = '';
    $isEpisodic = false;

    // Pattern: S01E02 or S1E2
    if (preg_match('/S(\d+)E(\d+)/i', $filename, $m)) {
        $season = (int)$m[1];
        $episode = (int)$m[2];
        $isEpisodic = true;
    }
    // Pattern: 1x02
    else if (preg_match('/(\d+)x(\d+)/i', $filename, $m)) {
        $season = (int)$m[1];
        $episode = (int)$m[2];
        $isEpisodic = true;
    }
    // Pattern: Cap/Ep 10 (Common in Novelas/Anime)
    else if (preg_match('/(Cap|Capitulo|Ep|Episode|Episodio)\s*(\d+)/i', $filename, $m)) {
        $episode = (int)$m[2];
        $isEpisodic = true;
    }
    
    $finalTitle = trim($cleanName);
    
    // 3. Logic for Series/Novelas Renaming
    // If it was detected as a group (Series/Novela) OR regex found episode info
    if ($detectedType === 'SERIES' || $detectedType === 'NOVELAS' || $isEpisodic) {
        
        // If we found Season/Ep info, format nicely
        if ($season !== '' && $episode !== '') {
            $s = str_pad($season, 2, '0', STR_PAD_LEFT);
            $e = str_pad($episode, 2, '0', STR_PAD_LEFT);
            // Use folder name as Series Name if filename is obscure
            if (strlen($finalTitle) < 5) {
                $finalTitle = "$folderName - S{$s}E{$e}";
            } else {
                // If title already has the info, just ensure format
                $finalTitle = preg_replace('/S\d+E\d+/i', '', $finalTitle); // Remove old code
                $finalTitle = trim($folderName) . " - " . trim($finalTitle) . " S{$s}E{$e}";
            }
        } elseif ($episode !== '') {
            $e = str_pad($episode, 2, '0', STR_PAD_LEFT);
            // Likely a Novela or Anime
            $finalTitle = "$folderName - Cap $e";
        } else {
            // Fallback: It's in a series folder but no number found. Just use filename.
            // Maybe prepend folder name if filename is generic "Video 1"
            if (stripos($filename, $folderName) === false) {
                $finalTitle = "$folderName - $finalTitle";
            }
        }
    }

    // Capitalize nicely
    $finalTitle = ucwords(strtolower($finalTitle));
    
    // Override category if episodic info found
    $finalCategory = $detectedType;
    if (!$finalCategory && $isEpisodic) {
        $finalCategory = 'SERIES';
    }

    return [
        'title' => $finalTitle,
        'category' => $finalCategory
    ];
}

// Advanced Streaming with open_basedir bypass support (via FTP fallback)
function streamVideo($path, $pdo) {
    // 1. Check direct file access
    if (!file_exists($path)) {
        // 2. If missing, check if it's a NAS path blocked by open_basedir
        // We try to read FTP config from DB to fallback
        $stmt = $pdo->query("SELECT ftpSettings FROM system_settings LIMIT 1");
        $settings = $stmt->fetch(PDO::FETCH_ASSOC);
        $ftpConfig = $settings ? json_decode($settings['ftpSettings'], true) : null;

        if ($ftpConfig && !empty($ftpConfig['host']) && function_exists('ftp_connect')) {
            // Attempt FTP Stream
            $ftp_conn = @ftp_connect($ftpConfig['host'], $ftpConfig['port']);
            if ($ftp_conn && @ftp_login($ftp_conn, $ftpConfig['user'], $ftpConfig['pass'])) {
                ftp_pasv($ftp_conn, true);
                
                // Determine file size via FTP
                $size = @ftp_size($ftp_conn, $path);
                if ($size != -1) {
                    // It exists on FTP. Stream it through PHP output.
                    header("Content-Type: video/mp4");
                    header("Content-Length: " . $size);
                    // Use a temporary handle to stream output
                    $out = fopen('php://output', 'w');
                    @ftp_fget($ftp_conn, $out, $path, FTP_BINARY);
                    fclose($out);
                    ftp_close($ftp_conn);
                    exit;
                }
                ftp_close($ftp_conn);
            }
        }
        
        http_response_code(404);
        die("Video file not found: " . $path);
    }

    // 3. Standard Local Streaming
    $size = filesize($path);
    $length = $size;
    $start = 0;
    $end = $size - 1;

    header("Content-Type: video/mp4");
    header("Accept-Ranges: bytes");

    if (isset($_SERVER['HTTP_RANGE'])) {
        list(, $range) = explode('=', $_SERVER['HTTP_RANGE'], 2);
        if (strpos($range, ',') !== false) {
            header('HTTP/1.1 416 Requested Range Not Satisfiable');
            header("Content-Range: bytes $start-$end/$size");
            exit;
        }
        if ($range == '-') {
            $c_start = $size - substr($range, 1);
        } else {
            $range = explode('-', $range);
            $c_start = $range[0];
            $c_end = (isset($range[1]) && is_numeric($range[1])) ? $range[1] : $size;
        }
        $c_end = ($c_end > $end) ? $end : $c_end;
        if ($c_start > $c_end || $c_start > $size - 1 || $c_end >= $size) {
            header('HTTP/1.1 416 Requested Range Not Satisfiable');
            header("Content-Range: bytes $start-$end/$size");
            exit;
        }
        $start = $c_start;
        $end = $c_end;
        $length = $end - $start + 1;
        header('HTTP/1.1 206 Partial Content');
        header("Content-Range: bytes $start-$end/$size");
    }
    
    header("Content-Length: " . $length);
    $fp = fopen($path, 'rb');
    fseek($fp, $start);
    $buffer = 1024 * 8;
    while (!feof($fp) && ($p = ftell($fp)) <= $end) {
        if ($p + $buffer > $end) {
            $buffer = $end - $p + 1;
        }
        set_time_limit(0);
        echo fread($fp, $buffer);
        flush();
    }
    fclose($fp);
    exit;
}

// --- NEW DESCRIPTION HELPERS ---

function findLocalDescription($filePath) {
    $dir = dirname($filePath);
    $name = pathinfo($filePath, PATHINFO_FILENAME);
    
    // 1. Specific text file: video_name.txt/nfo
    $specific = ["$dir/$name.txt", "$dir/$name.nfo"];
    foreach ($specific as $f) {
        if (file_exists($f)) {
            $content = @file_get_contents($f);
            if ($content && strlen(trim($content)) > 5) return trim($content);
        }
    }
    
    // 2. Generic text file in folder
    $generic = ["$dir/info.txt", "$dir/desc.txt", "$dir/description.txt", "$dir/sinopsis.txt"];
    foreach ($generic as $f) {
        if (file_exists($f)) {
            $content = @file_get_contents($f);
            if ($content && strlen(trim($content)) > 5) return trim($content);
        }
    }
    
    return null;
}

function fetchOnlineDescription($title, $category) {
    // Extract Clean Search Term
    $query = $title;
    
    // If Series/Novela, strip " - S01E05" etc to find the main show summary
    if ($category === 'SERIES' || $category === 'NOVELAS') {
        // Remove " - S\d+E\d+"
        $query = preg_replace('/ - S\d+E\d+.*$/i', '', $query);
        $query = preg_replace('/ - Cap.*$/i', '', $query);
        // If smartParseFilename formatted it as "Show - Ep Title", extract "Show"
        $parts = explode(' - ', $query);
        if (count($parts) > 0) $query = $parts[0];
    }
    
    // Wikipedia API (Spanish)
    $url = "https://es.wikipedia.org/w/api.php?action=query&format=json&prop=extracts&exintro&explaintext&redirects=1&titles=" . urlencode($query);
    
    // 2s timeout to avoid hanging the batch process
    $ctx = stream_context_create(['http' => ['timeout' => 2]]); 
    $res = @file_get_contents($url, false, $ctx);
    
    if ($res) {
        $data = json_decode($res, true);
        if (!empty($data['query']['pages'])) {
            foreach ($data['query']['pages'] as $page) {
                if (!isset($page['missing']) && !empty($page['extract'])) {
                    $txt = $page['extract'];
                    if (strlen($txt) > 600) $txt = substr($txt, 0, 597) . "...";
                    return $txt . "\n\n(Fuente: Wikipedia)";
                }
            }
        }
    }
    
    return null;
}
?>