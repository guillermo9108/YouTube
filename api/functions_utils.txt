
<?php
function respond($success, $data = null, $error = null) {
    while (ob_get_level()) ob_end_clean(); 
    header('Content-Type: application/json');
    echo json_encode(['success' => $success, 'data' => $data, 'error' => $error]);
    exit();
}

function fix_url($url) {
    if (!empty($url) && strpos($url, 'uploads/') === 0) {
        return 'api/' . $url;
    }
    return $url;
}

function get_youtube_video($query, $config) {
    if (empty($config['enableYoutube']) || empty($config['ytDlpPath'])) return [];
    
    $bin = $config['ytDlpPath'];
    $cmd = "$bin \"ytsearch10:$query\" --dump-json --flat-playlist --no-warnings 2>&1";
    exec($cmd, $output, $ret);
    
    $results = [];
    foreach ($output as $line) {
        $data = json_decode($line, true);
        if ($data) {
            $results[] = [
                'id' => $data['id'],
                'source' => 'YouTube',
                'thumbnail' => "https://i.ytimg.com/vi/{$data['id']}/hqdefault.jpg",
                'title' => $data['title'],
                'duration' => $data['duration'] ?? 0,
                'downloadUrl' => "https://www.youtube.com/watch?v={$data['id']}",
                'author' => $data['uploader'] ?? 'Unknown'
            ];
        }
    }
    return $results;
}

function detectCategoryFromDuration($duration) {
    if ($duration <= 0) return 'OTRO'; 
    if ($duration <= 180) return 'SHORTS'; 
    if ($duration <= 300) return 'MUSICA'; 
    if ($duration <= 1500) return 'CORTOMETRAJE'; 
    if ($duration <= 2700) return 'SERIES'; 
    return 'PELICULA'; 
}

function getPriceForCategory($cat, $settings) {
    $prices = json_decode($settings['categoryPrices'] ?? '{}', true);
    return isset($prices[$cat]) ? $prices[$cat] : 1; 
}

function smartParseFilename($fullPath, $existingCategory = null, $customCategories = []) {
    $filename = pathinfo($fullPath, PATHINFO_FILENAME);
    
    // Normalizar separadores
    $fullPathNormalized = str_replace('\\', '/', $fullPath);
    // Obtener array de carpetas
    $pathParts = explode('/', dirname($fullPathNormalized));
    
    // Carpetas genéricas a ignorar al buscar nombres de series/títulos
    $genericFolders = ['series', 'serie', 'season', 'temporada', 'downloads', 'descargas', 'anime', 'tv shows', 'completed', 'videos', 'uploads', 'torrents', 'storage', 'public', 'media', '4k', '1080p'];

    $detectedCategory = null;
    $categoryLocked = false; // Flag crucial: Si es true, nadie más puede cambiar la categoría

    // --- PASO 1: PRIORIDAD ABSOLUTA - CATEGORÍAS PERSONALIZADAS EN ANCESTROS ---
    // Analizamos Padre, Abuelo y Bisabuelo
    if (!empty($customCategories)) {
        // Tomar las últimas 3 carpetas e invertirlas (Padre > Abuelo > Bisabuelo)
        $ancestors = array_reverse(array_slice($pathParts, -3)); 
        
        foreach ($ancestors as $folder) {
            // Normalizar nombre carpeta: "Ciencia_Ficcion" -> "ciencia ficcion"
            $folderClean = mb_strtolower(str_replace(['_', '-', '.'], ' ', trim($folder)), 'UTF-8');
            
            foreach ($customCategories as $customCat) {
                // Normalizar categoría custom: "CIENCIA_FICCION" -> "ciencia ficcion"
                $catName = mb_strtolower(str_replace(['_', '-'], ' ', trim($customCat)), 'UTF-8');
                
                // Coincidencia: La carpeta CONTIENE el nombre de la categoría o es IGUAL
                // Ej: Carpeta "Peliculas Retro" match con Categoría "RETRO"
                if ($folderClean === $catName || strpos($folderClean, $catName) !== false) {
                    $detectedCategory = $customCat;
                    $categoryLocked = true; // Bloquear cambios futuros
                    break 2; // Éxito, salir de ambos bucles
                }
            }
        }
    }

    // --- PASO 2: CATEGORÍAS ESTÁNDAR EN ANCESTROS (Solo si no está bloqueado) ---
    if (!$categoryLocked) {
        $categoryMap = [
            'SERIES' => ['series', 'serie', 'temporada', 'season', 'tv shows', 'capitulos', 'episodes', 'anime'],
            'NOVELAS' => ['novelas', 'telenovelas', 'dramas', 'soap'],
            'MOVIE' => ['movies', 'movie', 'peliculas', 'pelicula', 'films', 'cine', '4k movies', 'hd movies'],
            'SHORTS' => ['shorts', 'cortos', 'tiktok', 'reels', 'vertical'],
            'MUSIC' => ['music', 'musica', 'concerts', 'conciertos', 'videoclips'],
            'EDUCATION' => ['education', 'educacion', 'cursos', 'courses', 'tutoriales']
        ];

        // Revisar ancestros de nuevo para keywords estándar
        $ancestors = array_reverse(array_slice($pathParts, -3));
        foreach ($ancestors as $folder) {
            $p = mb_strtolower(str_replace(['_', '-', '.'], ' ', trim($folder)), 'UTF-8');
            foreach ($categoryMap as $catKey => $keywords) {
                foreach ($keywords as $kw) {
                    // Match de palabra completa o contenido claro
                    if (strpos($p, $kw) !== false) {
                        $detectedCategory = $catKey;
                        // No bloqueamos aquí ($categoryLocked = false) porque el análisis de episodio (Paso 3) podría ser más preciso (ej: detectar S01E01 en carpeta 'Descargas')
                        break 3; 
                    }
                }
            }
        }
    }

    // --- PASO 3: ANÁLISIS DE ARCHIVO/CARPETA (EPISODIOS) ---
    $season = '';
    $episode = '';
    $episodeEnd = ''; 
    $isEpisodic = false;

    // Función auxiliar para buscar patrones S01E01
    $findEpisodeInfo = function($str) {
        $res = ['s'=>'', 'e'=>'', 'e2'=>'', 'found'=>false];
        // S01E01
        if (preg_match('/S(\d+)\s*E(\d+)(?:-?E?(\d+))?/i', $str, $m)) {
            $res['s'] = (int)$m[1]; $res['e'] = (int)$m[2]; 
            if(isset($m[3])) $res['e2'] = (int)$m[3];
            $res['found'] = true;
        }
        // 1x01
        else if (preg_match('/(\d+)[xX](\d+)/', $str, $m)) {
            $res['s'] = (int)$m[1]; $res['e'] = (int)$m[2]; $res['found'] = true;
        }
        // Cap/Ep 01
        else if (preg_match('/(Cap|Capitulo|Ep|Episode|Episodio)\s*[-.]?\s*(\d+)/i', $str, $m)) {
            $res['e'] = (int)$m[2]; $res['found'] = true;
        }
        // Anime absoluto (e.g. "One Piece - 1050" o " [1050] ")
        else if (preg_match('/[ \-\[\(](\d{2,4})[ \-\]\)]/', $str, $m)) {
             $num = (int)$m[1];
             if ($num < 1900 || $num > 2100) { $res['e'] = $num; $res['found'] = true; }
        }
        return $res;
    };

    // Buscar en archivo
    $info = $findEpisodeInfo($filename);
    
    // Si no, buscar en carpeta padre
    $parentFolder = end($pathParts);
    if (!$info['found']) {
        $parentInfo = $findEpisodeInfo($parentFolder);
        if ($parentInfo['found']) {
            $info = $parentInfo;
        }
    }

    if ($info['found']) {
        $season = $info['s'];
        $episode = $info['e'];
        $episodeEnd = $info['e2'];
        $isEpisodic = true;

        // IMPORTANTE: Si NO está bloqueado por una categoría personalizada, asignamos SERIES/NOVELAS
        if (!$categoryLocked) {
            // Si ya habíamos detectado algo genérico como 'OTHER' o 'PROCESSING' o nada, forzamos SERIES
            if (!$detectedCategory || $detectedCategory === 'OTHER' || $detectedCategory === 'PROCESSING' || $detectedCategory === 'MOVIE') {
                $detectedCategory = ($detectedCategory === 'NOVELAS') ? 'NOVELAS' : 'SERIES';
            }
        }
    }

    // --- PASO 4: LIMPIEZA DE TÍTULO ---
    $junkPatterns = [
        '/\b(2160p|1080p|720p|480p|4k|8k|hd|sd|fhd|uhd)\b/i',
        '/\b(x264|x265|h264|h265|hevc|av1|divx|xvid|mpeg4|mpeg)\b/i',
        '/\b(aac|ac3|eac3|dts|truehd|flac|mp3|atmos|dd5\.1|dd\+|5\.1|7\.1)\b/i',
        '/\b(hdr|hdr10|dv|dolby|vision|10bit|8bit|sdr)\b/i',
        '/\b(bluray|web-dl|webrip|hdrip|hdtv|dvdrip|camrip|remux|bdrip|web)\b/i',
        '/\b(amzn|nf|hulu|dsnp|netflix|amazon|rarbg|yify|eztv|etrg|psa)\b/i',
        '/\b(mkv|mp4|avi|mov)\b/i',
        '/www\.[a-z0-9-]+\.[a-z]+/i',
        ($detectedCategory === 'SERIES' || $detectedCategory === 'NOVELAS' || $categoryLocked) ? '/\b(19|20)\d{2}\b/' : '' // Quitar año si es serie
    ];

    $cleanText = function($txt) use ($junkPatterns) {
        $t = str_replace(['.', '_', '-', '[', ']', '(', ')'], ' ', $txt);
        foreach ($junkPatterns as $p) { if($p) $t = preg_replace($p, '', $t); }
        return trim(preg_replace('/\s+/', ' ', $t));
    };

    $cleanName = $cleanText($filename);
    $finalTitle = $cleanName;

    // Lógica especial para Títulos de Series (incluso si la categoría es custom pero tiene estructura de episodios)
    if ($detectedCategory === 'SERIES' || $detectedCategory === 'NOVELAS' || ($isEpisodic && $detectedCategory !== 'MOVIE')) {
        $grandParent = prev($pathParts);

        $cleanParent = $cleanText($parentFolder);
        // Quitar también patrones de episodio del nombre de la carpeta padre
        $cleanParent = preg_replace('/S\d+\s*E\d+/i', '', $cleanParent);
        $cleanParent = preg_replace('/\d+x\d+/i', '', $cleanParent);
        
        if (is_numeric(trim($cleanParent))) $cleanParent = "";
        $cleanParent = trim($cleanParent);

        $seriesName = "";
        if (strlen($cleanParent) > 2 && !in_array(strtolower($cleanParent), $genericFolders)) {
            $seriesName = $cleanParent;
        } else if (!empty($grandParent)) {
            $cleanGrandParent = $cleanText($grandParent);
            if (!in_array(strtolower($cleanGrandParent), $genericFolders)) {
                $seriesName = $cleanGrandParent;
            }
        }

        // Formato Episodio
        $epString = "";
        if ($season !== '' && $episode !== '') {
            $s = str_pad($season, 2, '0', STR_PAD_LEFT);
            $e = str_pad($episode, 2, '0', STR_PAD_LEFT);
            $epString = "S{$s}E{$e}";
            if ($episodeEnd) $epString .= "-E".str_pad($episodeEnd, 2, '0', STR_PAD_LEFT);
        } elseif ($episode !== '') {
            if ($episode > 99) $epString = "Ep {$episode}"; 
            else $epString = ($detectedCategory === 'NOVELAS' ? 'Cap' : 'Ep') . " " . str_pad($episode, 2, '0', STR_PAD_LEFT);
        }

        if ($seriesName) {
            if ($epString) {
                $finalTitle = "$seriesName - $epString";
                // Añadir nombre del capítulo si existe en el archivo
                $nameWithoutEp = str_replace($epString, '', $cleanName);
                $nameWithoutEp = trim(preg_replace('/[^a-zA-Z0-9\s]/', '', $nameWithoutEp));
                
                if (strlen($nameWithoutEp) > 3 && stripos($seriesName, $nameWithoutEp) === false) {
                    $finalTitle .= " - $nameWithoutEp";
                }
            } else {
                $finalTitle = "$seriesName - $cleanName";
            }
        }
    }

    // Capitalización
    $finalTitle = ucwords(strtolower($finalTitle));
    $finalTitle = str_replace([' - - ', '  '], [' - ', ' '], $finalTitle);
    $finalTitle = trim($finalTitle, " -.");

    if (empty($finalTitle) || strlen($finalTitle) < 2) {
        $finalTitle = $filename;
    }
    
    // Si no detectamos nada nuevo, mantener la existente si es válida, o 'OTHER'
    if (!$detectedCategory) {
        if ($existingCategory && $existingCategory !== 'PENDING' && $existingCategory !== 'PROCESSING') {
            $detectedCategory = $existingCategory;
        } else {
            $detectedCategory = 'OTHER';
        }
    }
    
    return [
        'title' => $finalTitle,
        'category' => $detectedCategory
    ];
}

function streamVideo($filePath, $pdo) {
    // AGGRESSIVE BUFFER CLEANING - CRITICAL FOR VIDEO STREAMS
    // Must clear all existing output buffers (whitespace, includes)
    if (function_exists('ini_set')) {
        ini_set('zlib.output_compression', 'Off');
    }
    while (ob_get_level() > 0) ob_end_clean();
    
    ini_set('display_errors', 0);
    error_reporting(0);
    set_time_limit(0);

    header('Access-Control-Allow-Origin: *');
    header('Access-Control-Allow-Methods: GET, HEAD, OPTIONS');
    header('Access-Control-Expose-Headers: Content-Length, Content-Range, Content-Type');
    header('Connection: close');
    
    if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { exit(0); }

    // Check FTP (Redundant query here but safe for integrity, assumes $pdo is passed)
    // To optimize, index_code.txt could pass $isLocal, but maintaining function signature is safer for now.
    $stmt = $pdo->prepare("SELECT isLocal FROM videos WHERE videoUrl = ? OR videoUrl = ? LIMIT 1");
    $stmt->execute([$filePath, "api/" . $filePath]);
    $isLocal = $stmt->fetchColumn();

    if ($isLocal == 2) {
        // FTP PROXY
        $sStmt = $pdo->query("SELECT ftpSettings FROM system_settings LIMIT 1");
        $json = $sStmt->fetchColumn();
        $s = json_decode($json, true);
        
        if (!$s || empty($s['host'])) { http_response_code(500); exit; }
        
        $authUrl = "ftp://" . urlencode($s['user']) . ":" . urlencode($s['pass']) . "@" . $s['host'] . ":" . ($s['port']??21) . $filePath;
        $context = stream_context_create(['ftp' => ['overwrite' => true]]);
        $resource = @fopen($authUrl, 'rb', false, $context);
        
        if (!$resource) { http_response_code(404); exit; }
        
        header('Content-Type: video/mp4');
        while (!feof($resource)) {
            echo fread($resource, 8192);
            flush();
            if (connection_aborted()) { fclose($resource); exit; }
        }
        fclose($resource);
        exit;
    } else {
        // LOCAL FILE
        $realPath = $filePath;
        if (!file_exists($realPath)) {
            $realPath = rawurldecode($filePath);
        }

        if (!file_exists($realPath)) {
            header("HTTP/1.0 404 Not Found");
            exit;
        }
        
        $fileSize = sprintf("%u", filesize($realPath));
        $ext = strtolower(pathinfo($realPath, PATHINFO_EXTENSION));
        $mimeTypes = [
            'mp4' => 'video/mp4', 'webm' => 'video/webm', 'mkv' => 'video/x-matroska', 
            'mov' => 'video/quicktime', 'avi' => 'video/x-msvideo', 'mp3' => 'audio/mpeg',
            'm4v' => 'video/mp4', 'mpg' => 'video/mpeg', 'mpeg' => 'video/mpeg'
        ];
        $contentType = isset($mimeTypes[$ext]) ? $mimeTypes[$ext] : 'video/mp4';
        
        header('Content-Type: ' . $contentType);
        header('Accept-Ranges: bytes');

        $offset = 0;
        $length = $fileSize;

        if (isset($_SERVER['HTTP_RANGE'])) {
            if (preg_match('/bytes=(\d+)-(\d+)?/', $_SERVER['HTTP_RANGE'], $matches)) {
                $offset = intval($matches[1]);
                $end = isset($matches[2]) && $matches[2] !== '' ? intval($matches[2]) : $fileSize - 1;
                if ($offset >= $fileSize || $end >= $fileSize || $offset > $end) {
                    header('HTTP/1.1 416 Requested Range Not Satisfiable');
                    header("Content-Range: bytes */$fileSize");
                    exit;
                }
                $length = $end - $offset + 1;
                header('HTTP/1.1 206 Partial Content');
                header("Content-Range: bytes $offset-$end/$fileSize");
            }
        } else {
            header("Content-Length: $fileSize");
        }
        
        if (headers_sent()) exit;

        $fp = fopen($realPath, 'rb');
        if ($offset > 0) fseek($fp, $offset);
        
        $buffer = 1024 * 256; // 256KB buffer chunks
        while (!feof($fp) && ($p = ftell($fp)) <= $offset + $length) {
            if ($p + $buffer > $offset + $length) $buffer = $offset + $length - $p + 1;
            echo fread($fp, $buffer);
            flush();
            // CRITICAL: Stop script if client disconnects to prevent server CPU hang
            if (connection_aborted()) {
                fclose($fp);
                exit;
            }
        }
        fclose($fp);
        exit;
    }
}
?>