<?php

function smartParseFilename($fullPath, $existingCategory = null, $hierarchy = []) {
    $filename = pathinfo($fullPath, PATHINFO_FILENAME);
    $fullPathNormalized = str_replace('\\', '/', $fullPath);
    $pathParts = explode('/', $fullPathNormalized);
    
    // 1. Limpieza básica del nombre
    $cleanText = function($txt) {
        $junk = ['/\b(1080p|720p|4k|x264|h264|bluray|web-dl|mkv|mp4)\b/i', '/\./', '/_/'];
        $t = $txt;
        foreach ($junk as $p) { $t = preg_replace($p, ' ', $t); }
        return trim(preg_replace('/\s+/', ' ', $t));
    };
    $cleanName = $cleanText($filename);

    $detectedCat = 'GENERAL';
    $detectedParent = null;
    $detectedCollection = null;

    // 2. Buscar coincidencia en la ruta con las categorías del administrador
    // Recorremos las partes de la ruta para detectar Categoría, Padre y Colección
    $partsCount = count($pathParts);
    foreach (array_reverse($pathParts) as $index => $segment) {
        if (empty($segment) || $segment === $filename) continue;

        foreach ($hierarchy as $cat) {
            if (strcasecmp($segment, $cat['name']) === 0) {
                $detectedCat = $cat['name'];
                
                // Si la categoría tiene auto-subcategorías (Modo Carpeta)
                if (!empty($cat['autoSub'])) {
                    // El índice original en el array $pathParts
                    $originalIndex = array_search($segment, $pathParts);
                    
                    // Si hay una subcarpeta después de la categoría detectada
                    if ($originalIndex !== false && isset($pathParts[$originalIndex + 1]) && $pathParts[$originalIndex + 1] !== $filename) {
                        $detectedParent = $cat['name'];
                        $detectedCat = $pathParts[$originalIndex + 1];
                        
                        // Si hay OTRA subcarpeta adicional, la tratamos como Colección/Serie
                        if (isset($pathParts[$originalIndex + 2]) && $pathParts[$originalIndex + 2] !== $filename) {
                            $detectedCollection = $pathParts[$originalIndex + 1];
                            $detectedCat = $pathParts[$originalIndex + 2];
                        }
                    }
                }
                break 2;
            }
        }
    }

    return [
        'title' => ucwords(strtolower($cleanName)), 
        'category' => $detectedCat,
        'parent_category' => $detectedParent,
        'collection' => $detectedCollection
    ];
}

function getPriceForCategory($catName, $settings) {
    $categories = is_array($settings['categories']) ? $settings['categories'] : json_decode($settings['categories'] ?? '[]', true);
    foreach ($categories as $cat) {
        if ($cat['name'] === $catName) return floatval($cat['price']);
    }
    return 1.00; 
}

function write_log($message, $level = 'INFO') {
    $logFile = __DIR__ . '/debug_log.txt';
    $timestamp = date('Y-m-d H:i:s');
    $formattedMessage = "[$timestamp] [$level] $message" . PHP_EOL;
    @file_put_contents($logFile, $formattedMessage, FILE_APPEND);
}

function resolve_video_path($pathOrUrl) {
    if (!$pathOrUrl) return false;
    
    // Normalizar
    $path = str_replace('\\', '/', $pathOrUrl);
    
    // 1. Si es absoluta y existe
    if (file_exists($path) && is_file($path)) return $path;
    
    // 2. Si es relativa a uploads (api/uploads/...)
    $cleanPath = (strpos($path, 'api/') === 0) ? substr($path, 4) : $path;
    $internalPath = __DIR__ . '/' . $cleanPath;
    if (file_exists($internalPath) && is_file($internalPath)) return realpath($internalPath);
    
    // 3. Intento de fallback agresivo (quitar api/ si existe)
    $fallback = str_replace('api/', '', $path);
    if (file_exists($fallback) && is_file($fallback)) return $fallback;

    write_log("Fallo al resolver ruta: Original($pathOrUrl) -> Intentado($path, $internalPath, $fallback)", 'ERROR');
    return false;
}

function fix_url($url) {
    if (empty($url)) return 'api/uploads/thumbnails/default.jpg';
    if (strpos($url, 'http') === 0) return $url;
    if (strpos($url, 'data:') === 0) return $url;
    $clean = ltrim($url, '/');
    if (strpos($clean, 'api/') === 0) return $clean;
    return 'api/' . $clean;
}

function streamVideo($id, $pdo) {
    while (ob_get_level()) ob_end_clean();
    $stmt = $pdo->prepare("SELECT videoUrl FROM videos WHERE id = ?");
    $stmt->execute([$id]);
    $videoUrl = $stmt->fetchColumn();
    
    if (!$videoUrl) { 
        header("HTTP/1.0 404 Not Found"); 
        write_log("Stream Error: ID $id no existe en DB", 'ERROR');
        exit; 
    }
    
    $realPath = resolve_video_path($videoUrl);
    if (!$realPath || !file_exists($realPath)) { 
        header("HTTP/1.0 404 Not Found"); 
        write_log("Stream Error: Archivo físico no existe para ID $id ($videoUrl)", 'ERROR');
        exit; 
    }

    $fileSize = sprintf("%u", filesize($realPath));
    $fp = fopen($realPath, 'rb');
    $ext = strtolower(pathinfo($realPath, PATHINFO_EXTENSION));
    $mime = ($ext === 'mkv') ? 'video/x-matroska' : (($ext === 'webm') ? 'video/webm' : 'video/mp4');
    
    header("Content-Type: $mime");
    header('Accept-Ranges: bytes');
    header('Cache-Control: public, max-age=3600');

    if (isset($_SERVER['HTTP_RANGE'])) {
        preg_match('/bytes=(\d+)-(\d+)?/', $_SERVER['HTTP_RANGE'], $matches);
        $offset = intval($matches[1]);
        $end = isset($matches[2]) ? intval($matches[2]) : $fileSize - 1;
        header('HTTP/1.1 206 Partial Content');
        header("Content-Range: bytes $offset-$end/$fileSize");
        header("Content-Length: " . ($end - $offset + 1));
        fseek($fp, $offset);
    } else { 
        header("Content-Length: $fileSize"); 
    }

    while (!feof($fp)) { 
        echo fread($fp, 1024 * 128); 
        flush(); 
        if (connection_aborted()) break; 
    }
    fclose($fp);
    exit;
}
?>