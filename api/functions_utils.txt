<?php

/**
 * Motor Avanzado de Descomposición de Rutas Jerárquicas
 */
function smartParseFilename($fullPath, $existingCategory = null, $hierarchy = []) {
    $filename = pathinfo($fullPath, PATHINFO_FILENAME);
    $fullPathNormalized = str_replace('\\', '/', $fullPath);
    $pathParts = explode('/', $fullPathNormalized);
    
    // 1. Limpieza de Título (Standard)
    $junkPatterns = ['/\b(2160p|1080p|720p|480p|4k|8k|hd|sd|fhd|uhd)\b/i', '/\b(x264|x265|h264|h265|hevc|av1|divx|xvid|mpeg4|mpeg)\b/i', '/\b(aac|ac3|eac3|dts|truehd|flac|mp3|atmos|dd5\.1|dd\+|5\.1|7\.1)\b/i', '/\b(hdr|hdr10|dv|dolby|vision|10bit|8bit|sdr)\b/i', '/\b(bluray|web-dl|webrip|hdrip|hdtv|dvdrip|camrip|remux|bdrip|web)\b/i', '/\b(amzn|nf|hulu|dsnp|netflix|amazon|rarbg|yify|eztv|etrg|psa)\b/i', '/\b(mkv|mp4|avi|mov|wmv|flv|ts)\b/i', '/www\.[a-z0-9-]+\.[a-z]+/i'];
    $cleanText = function($txt) use ($junkPatterns) {
        $t = str_replace(['.', '_', '-', '[', ']', '(', ')'], ' ', $txt);
        foreach ($junkPatterns as $p) { $t = preg_replace($p, '', $t); }
        return trim(preg_replace('/\s+/', ' ', $t));
    };
    $cleanName = $cleanText($filename);

    // 2. Traversal Profundo de Categoría
    $detectedCat = 'GENERAL';
    $detectedParent = null;
    
    // Si no hay jerarquía, usamos el legacy behavior
    if (empty($hierarchy)) return ['title' => ucwords(strtolower($cleanName)), 'category' => 'GENERAL', 'parent_category' => null, 'collection' => null];

    // Buscamos coincidencia en cada parte de la ruta, de atrás hacia adelante
    foreach (array_reverse($pathParts) as $segment) {
        if (empty($segment) || $segment === $filename) continue;
        
        $segUpper = strtoupper($segment);
        foreach ($hierarchy as $node) {
            $keywords = isset($node['keywords']) ? array_map('strtoupper', array_map('trim', explode(',', $node['keywords']))) : [];
            // Coincidencia por nombre exacto o palabras clave
            if ($segUpper === strtoupper($node['name']) || in_array($segUpper, $keywords)) {
                $detectedCat = $node['name'];
                $detectedParent = $node['parent'] ?? null;
                break 2;
            }
        }
    }

    // 3. Lógica de Colección (Agrupación por Carpeta)
    $parentFolder = (count($pathParts) > 1) ? $pathParts[count($pathParts)-2] : null;

    return [
        'title' => ucwords(strtolower($cleanName)), 
        'category' => $detectedCat,
        'parent_category' => $detectedParent,
        'collection' => $parentFolder
    ];
}

/**
 * Buscador de Precios Recursivo (Herencia)
 */
function getPriceForCategory($catName, $settings) {
    $hierarchy = json_decode($settings['categoryHierarchy'] ?? '[]', true);
    
    $findPrice = function($name) use (&$findPrice, $hierarchy) {
        foreach ($hierarchy as $node) {
            if ($node['name'] === $name) {
                if (isset($node['price']) && floatval($node['price']) > 0) {
                    return floatval($node['price']);
                }
                if (!empty($node['parent'])) {
                    return $findPrice($node['parent']);
                }
            }
        }
        return null;
    };

    $price = $findPrice($catName);
    if ($price !== null) return $price;

    // Fallback a precios planos legacy
    $prices = is_array($settings['categoryPrices']) ? $settings['categoryPrices'] : json_decode($settings['categoryPrices'] ?? '{}', true);
    return isset($prices[$catName]) ? floatval($prices[$catName]) : 1.00; 
}

function write_log($message, $level = 'INFO') {
    $logFile = __DIR__ . '/debug_log.txt';
    $timestamp = date('Y-m-d H:i:s');
    $formattedMessage = "[$timestamp] [$level] $message" . PHP_EOL;
    @file_put_contents($logFile, $formattedMessage, FILE_APPEND);
}

function resolve_video_path($pathOrUrl) {
    if (!$pathOrUrl) return false;
    if (file_exists($pathOrUrl)) return realpath($pathOrUrl);
    $cleanPath = (strpos($pathOrUrl, 'api/') === 0) ? substr($pathOrUrl, 4) : $pathOrUrl;
    if (file_exists($cleanPath)) return realpath($cleanPath);
    if (strpos($cleanPath, 'uploads/') !== false) {
        $baseDir = dirname(__DIR__); 
        $fullPath = $baseDir . DIRECTORY_SEPARATOR . $cleanPath;
        if (file_exists($fullPath)) return realpath($fullPath);
    }
    return false;
}

function fix_url($url) {
    if (!empty($url) && strpos($url, 'uploads/') === 0) return 'api/' . $url;
    return $url;
}

function streamVideo($id, $pdo) {
    while (ob_get_level()) ob_end_clean();
    $stmt = $pdo->prepare("SELECT videoUrl FROM videos WHERE id = ?");
    $stmt->execute([$id]);
    $videoUrl = $stmt->fetchColumn();
    if (!$videoUrl) { header("HTTP/1.0 404 Not Found"); exit; }
    $realPath = resolve_video_path($videoUrl);
    if (!$realPath || !file_exists($realPath)) { header("HTTP/1.0 404 Not Found"); exit; }
    $fileSize = sprintf("%u", filesize($realPath));
    $fp = fopen($realPath, 'rb');
    header('Content-Type: video/mp4');
    header('Accept-Ranges: bytes');
    header('Cache-Control: public, max-age=3600');
    if (isset($_SERVER['HTTP_RANGE'])) {
        preg_match('/bytes=(\d+)-(\d+)?/', $_SERVER['HTTP_RANGE'], $matches);
        $offset = intval($matches[1]);
        $end = isset($matches[2]) ? intval($matches[2]) : $fileSize - 1;
        header('HTTP/1.1 206 Partial Content');
        header("Content-Range: bytes $offset-$end/$fileSize");
        header("Content-Length: " . ($end - $offset + 1));
        fseek($fp, $offset);
    } else { header("Content-Length: $fileSize"); }
    while (!feof($fp)) { echo fread($fp, 131072); flush(); if (connection_aborted()) break; }
    fclose($fp);
    exit;
}
?>