
<?php
function respond($success, $data = null, $error = null) {
    while (ob_get_level()) ob_end_clean(); // Clean buffer for JSON response
    header('Content-Type: application/json');
    echo json_encode(['success' => $success, 'data' => $data, 'error' => $error]);
    exit();
}

function fix_url($url) {
    if (!empty($url) && strpos($url, 'uploads/') === 0) {
        return 'api/' . $url;
    }
    return $url;
}

function get_youtube_video($query, $config) {
    if (empty($config['enableYoutube']) || empty($config['ytDlpPath'])) return [];
    
    $bin = $config['ytDlpPath'];
    $cmd = "$bin \"ytsearch10:$query\" --dump-json --flat-playlist --no-warnings 2>&1";
    exec($cmd, $output, $ret);
    
    $results = [];
    foreach ($output as $line) {
        $data = json_decode($line, true);
        if ($data) {
            $results[] = [
                'id' => $data['id'],
                'source' => 'YouTube',
                'thumbnail' => "https://i.ytimg.com/vi/{$data['id']}/hqdefault.jpg",
                'title' => $data['title'],
                'duration' => $data['duration'] ?? 0,
                'downloadUrl' => "https://www.youtube.com/watch?v={$data['id']}",
                'author' => $data['uploader'] ?? 'Unknown'
            ];
        }
    }
    return $results;
}

// Helper: Auto Categorize based on duration
function detectCategoryFromDuration($duration) {
    if ($duration <= 0) return 'OTRO'; 
    if ($duration <= 180) return 'SHORTS'; // < 3 min
    if ($duration <= 300) return 'MUSICA'; // < 5 min
    if ($duration <= 1500) return 'CORTOMETRAJE'; // < 25 min
    if ($duration <= 2700) return 'SERIES'; // < 45 min
    return 'PELICULA'; // > 45 min
}

// Helper: Get Price from Settings
function getPriceForCategory($cat, $settings) {
    $prices = json_decode($settings['categoryPrices'] ?? '{}', true);
    return isset($prices[$cat]) ? $prices[$cat] : 1; 
}

// Helper: Smart Filename Cleaning & Parsing
function smartParseFilename($fullPath, $detectedType = null) {
    $filename = pathinfo($fullPath, PATHINFO_FILENAME);
    $folderName = basename(dirname($fullPath));
    
    // 1. Clean common "junk"
    $junk = [
        '/1080p/i', '/720p/i', '/480p/i', '/x264/i', '/h264/i', '/x265/i', '/HEVC/i', 
        '/AAC/i', '/AC3/i', '/BluRay/i', '/WEB-DL/i', '/WEBRip/i', '/HDRip/i', 
        '/www\..+\.com/i', '/\[.*?\]/', '/\(.*?\)/'
    ];
    $cleanName = preg_replace($junk, '', $filename);
    $cleanName = str_replace(['.', '_'], ' ', $cleanName);
    
    // 2. Detect Season/Episode
    $season = '';
    $episode = '';
    $isEpisodic = false;

    if (preg_match('/S(\d+)E(\d+)/i', $filename, $m)) {
        $season = (int)$m[1];
        $episode = (int)$m[2];
        $isEpisodic = true;
    }
    else if (preg_match('/(\d+)x(\d+)/i', $filename, $m)) {
        $season = (int)$m[1];
        $episode = (int)$m[2];
        $isEpisodic = true;
    }
    else if (preg_match('/(Cap|Capitulo|Ep|Episode|Episodio)\s*(\d+)/i', $filename, $m)) {
        $episode = (int)$m[2];
        $isEpisodic = true;
    }
    
    $finalTitle = trim($cleanName);
    
    // 3. Logic for Series/Novelas Renaming
    if ($detectedType === 'SERIES' || $detectedType === 'NOVELAS' || $isEpisodic) {
        if ($season !== '' && $episode !== '') {
            $s = str_pad($season, 2, '0', STR_PAD_LEFT);
            $e = str_pad($episode, 2, '0', STR_PAD_LEFT);
            
            // Logic: If filename is generic, use folder name
            if (stripos($filename, $folderName) === false && strlen($finalTitle) < 5) {
                 $finalTitle = "$folderName - S{$s}E{$e}";
            } else {
                 $finalTitle = "$folderName - " . preg_replace('/S\d+E\d+/i', '', $finalTitle) . " S{$s}E{$e}";
            }
        } elseif ($episode !== '') {
            $e = str_pad($episode, 2, '0', STR_PAD_LEFT);
            $finalTitle = "$folderName - Cap $e";
        }
    }

    $finalTitle = ucwords(strtolower($finalTitle));
    $finalTitle = preg_replace('/\s+/', ' ', $finalTitle); // Remove double spaces
    
    $finalCategory = $detectedType;
    if (!$finalCategory && $isEpisodic) {
        $finalCategory = 'SERIES';
    }

    return [
        'title' => $finalTitle,
        'category' => $finalCategory
    ];
}

// STANDARD HTTP RANGE STREAMING FUNCTION (Supports Local & FTP Proxy)
function streamVideo($filePath, $pdo) {
    // Disable output compression which messes with Range headers
    if(ini_get('zlib.output_compression')) ini_set('zlib.output_compression', 'Off');

    // Clean all buffers aggressively to prevent corruption
    while (ob_get_level()) ob_end_clean();
    
    // Disable time limit for long streams
    set_time_limit(0);

    // Headers - CRITICAL: Always send Access-Control-Allow-Origin
    header('Access-Control-Allow-Origin: *');
    header('Access-Control-Allow-Methods: GET, HEAD, OPTIONS');
    header('Access-Control-Allow-Headers: Range');
    header('Access-Control-Expose-Headers: Content-Range, Content-Length, Accept-Ranges');
    header('Accept-Ranges: bytes'); // Default to bytes, will overwrite if FTP can't support it

    $fileSize = 0;
    $isFtp = false;
    $resource = null;

    // --- CHECK IF FTP PROXY NEEDED ---
    $stmt = $pdo->prepare("SELECT isLocal FROM videos WHERE videoUrl = ? OR videoUrl = ? LIMIT 1");
    // Try matching both full path or relative API path
    $stmt->execute([$filePath, "api/" . $filePath]);
    $isLocal = $stmt->fetchColumn();

    if ($isLocal == 2) {
        // --- FTP STREAMING MODE ---
        $isFtp = true;
        // Retrieve credentials securely
        $sStmt = $pdo->query("SELECT ftpSettings FROM system_settings LIMIT 1");
        $json = $sStmt->fetchColumn();
        $s = json_decode($json, true);
        
        if (!$s || empty($s['host'])) { http_response_code(500); die("FTP Config Missing"); }
        
        // Build Authenticated URL
        $authUrl = "ftp://" . urlencode($s['user']) . ":" . urlencode($s['pass']) . "@" . $s['host'] . ":" . ($s['port']??21) . $filePath;
        
        $context = stream_context_create(['ftp' => ['overwrite' => true]]);
        $resource = @fopen($authUrl, 'rb', false, $context);
        
        if (!$resource) { http_response_code(404); die("FTP File unreachable"); }
        
        // Try to determine size logic (simplified for reliability)
        // Note: Accurately seeking FTP in PHP without downloading whole file is tricky depending on server support.
        // We rely on standard stream passthru for basic playback.
        header('Content-Type: video/mp4');
        fpassthru($resource);
        fclose($resource);
        exit;

    } else {
        // --- LOCAL FILE MODE ---
        if (!file_exists($filePath)) {
            http_response_code(404);
            die("File not found");
        }
        $fileSize = filesize($filePath);
        $resource = fopen($filePath, 'rb');
    }

    // --- SHARED STREAMING LOGIC (Range Support) ---
    
    $offset = 0;
    $length = $fileSize;

    // Determine MIME type
    $ext = strtolower(pathinfo($filePath, PATHINFO_EXTENSION));
    $mimeTypes = [
        'mp4' => 'video/mp4',
        'webm' => 'video/webm',
        'mkv' => 'video/mp4', // Trick for some browsers to try playing MKV container
        'mov' => 'video/quicktime',
        'avi' => 'video/x-msvideo',
        'mp3' => 'audio/mpeg'
    ];
    $contentType = isset($mimeTypes[$ext]) ? $mimeTypes[$ext] : 'application/octet-stream';
    header('Content-Type: ' . $contentType);

    // Range Handling
    if (isset($_SERVER['HTTP_RANGE'])) {
        if (preg_match('/bytes=(\d+)-(\d+)?/', $_SERVER['HTTP_RANGE'], $matches)) {
            $offset = intval($matches[1]);
            $end = isset($matches[2]) && $matches[2] !== '' ? intval($matches[2]) : $fileSize - 1;
            
            if ($offset >= $fileSize || $end >= $fileSize || $offset > $end) {
                header('HTTP/1.1 416 Requested Range Not Satisfiable');
                header('Content-Range: bytes */' . $fileSize);
                exit;
            }

            $length = $end - $offset + 1;
            header('HTTP/1.1 206 Partial Content');
            header("Content-Range: bytes $offset-$end/$fileSize");
        }
    } else {
        header("Content-Length: $fileSize");
    }
    
    if (isset($_SERVER['HTTP_RANGE'])) {
        header("Content-Length: $length");
    }

    // Seek
    if ($offset > 0) {
        fseek($resource, $offset);
    }
    
    // Output loop
    $bufferSize = 1024 * 64; // 64KB chunks
    $bytesSent = 0;
    
    while (!feof($resource) && $bytesSent < $length && !connection_aborted()) {
        $readSize = min($bufferSize, $length - $bytesSent);
        $buffer = fread($resource, $readSize);
        echo $buffer;
        flush();
        $bytesSent += strlen($buffer);
    }
    
    fclose($resource);
    exit;
}
?>
