<?php
/**
 * StreamPay - Server-Side Video Worker V1.1 (Optimizado para Xpenology/Synology)
 * Procesa la cola de videos PENDING de forma automática.
 * Ejecución recomendada en Programador de Tareas: php video_worker.php
 */

// Aumentar límites para procesos largos
set_time_limit(300); // 5 minutos por ejecución
ini_set('memory_limit', '512M');

require_once 'functions_utils.php';
require_once 'functions_videos.php';

// 1. Cargar Configuración de BD
$configFile = 'db_config.json';
if (!file_exists($configFile)) {
    die("Error: Sistema no instalado (Falta db_config.json)\n");
}
$config = json_decode(file_get_contents($configFile), true);

try {
    $dsn = "mysql:host={$config['host']};port={$config['port']};dbname={$config['name']};charset=utf8mb4";
    $pdo = new PDO($dsn, $config['user'], $config['password'], [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
    ]);
} catch (PDOException $e) {
    write_log("Worker Connection Error: " . $e->getMessage(), 'FATAL');
    die("Error de conexión BD\n");
}

// 2. Autodetección de Rutas FFmpeg (Específico para DSM)
$stmtS = $pdo->query("SELECT ffmpegPath FROM system_settings WHERE id = 1");
$sysFfmpeg = $stmtS->fetchColumn();

$ffmpegPaths = [
    $sysFfmpeg,
    '/usr/local/ffmpeg/bin/ffmpeg', // SynoCommunity (Recomendado)
    '/usr/bin/ffmpeg',               // Default Synology
    'ffmpeg'                         // PATH
];

$ffmpeg = 'ffmpeg';
foreach ($ffmpegPaths as $path) {
    if ($path && @shell_exec("$path -version")) {
        $ffmpeg = $path;
        break;
    }
}
$ffprobe = str_replace('ffmpeg', 'ffprobe', $ffmpeg);

// 3. Procesamiento por Lotes (Batch Mode)
$batchSize = 5;
$processedCount = 0;

write_log("Worker iniciado. Usando: $ffmpeg", 'INFO');

for ($i = 0; $i < $batchSize; $ i++) {
    $now = time();
    $lockTimeout = $now - 600; // 10 minutos

    // Buscar video pendiente
    $stmt = $pdo->prepare("SELECT * FROM videos WHERE category = 'PENDING' AND processing_attempts < 3 AND locked_at < ? ORDER BY createdAt ASC LIMIT 1");
    $stmt->execute([$lockTimeout]);
    $video = $stmt->fetch();

    if (!$video) {
        if ($processedCount === 0) echo "Cola vacía.\n";
        break;
    }

    $processedCount++;
    // Bloquear registro
    $pdo->prepare("UPDATE videos SET locked_at = ? WHERE id = ?")->execute([$now, $video['id']]);

    echo "[$processedCount/$batchSize] Procesando: {$video['title']}...\n";

    $realPath = resolve_video_path($video['videoUrl']);
    if (!$realPath || !file_exists($realPath)) {
        write_log("Worker: Archivo no encontrado - {$video['videoUrl']}", 'ERROR');
        $pdo->prepare("UPDATE videos SET category = 'FAILED_METADATA', reason = 'Archivo no encontrado', locked_at = 0 WHERE id = ?")->execute([$video['id']]);
        continue;
    }

    // Identificar si es audio
    $ext = strtolower(pathinfo($realPath, PATHINFO_EXTENSION));
    $isAudio = in_array($ext, ['mp3', 'wav', 'aac', 'm4a', 'flac']) || (isset($video['is_audio']) && $video['is_audio']);

    // Extraer Duración
    $probeCmd = "$ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 " . escapeshellarg($realPath);
    $durationStr = shell_exec($probeCmd);
    $duration = floor(floatval(trim($durationStr)));

    if ($duration <= 0) {
        $attempts = $video['processing_attempts'] + 1;
        $status = ($attempts >= 3) ? 'FAILED_METADATA' : 'PENDING';
        $pdo->prepare("UPDATE videos SET processing_attempts = ?, category = ?, locked_at = 0 WHERE id = ?")
            ->execute([$attempts, $status, $video['id']]);
        write_log("Worker: Error duración en {$video['title']} (Intento $attempts)", 'WARNING');
        continue;
    }

    $thumbPath = null;
    if (!$isAudio) {
        $thumbFile = 'uploads/thumbnails/' . $video['id'] . '.jpg';
        $fullThumbPath = __DIR__ . '/' . $thumbFile;
        
        $captureTime = ($duration > 5) ? "00:00:02" : "00:00:00.5";
        // DSM Tip: -vcodec mjpeg para mayor compatibilidad de hardware
        $ffmpegCmd = "$ffmpeg -y -ss $captureTime -i " . escapeshellarg($realPath) . " -frames:v 1 -q:v 4 -f image2 " . escapeshellarg($fullThumbPath) . " 2>&1";
        
        exec($ffmpegCmd, $outputLog, $returnVar);
        
        if ($returnVar === 0 && file_exists($fullThumbPath)) {
            $thumbPath = 'api/' . $thumbFile;
        } else {
            write_log("Worker: Falló miniatura en {$video['title']}. Error: " . end($outputLog), 'WARNING');
        }
    } else {
        $thumbPath = 'api/uploads/thumbnails/defaultaudio.jpg';
    }

    // Guardar Metadatos y Pasar a Paso 3
    $fields = ["duration = ?", "category = 'PROCESSING'", "locked_at = 0", "processing_attempts = 0"];
    $params = [$duration];

    if ($thumbPath) {
        $fields[] = "thumbnailUrl = ?";
        $params[] = $thumbPath;
    }

    $params[] = $video['id'];
    $sql = "UPDATE videos SET " . implode(', ', $fields) . " WHERE id = ?";
    $pdo->prepare($sql)->execute($params);

    // Organización IA Automática
    $settingsArr = $pdo->query("SELECT * FROM system_settings WHERE id = 1")->fetch();
    video_organize_single($pdo, $video['id'], $settingsArr);
    
    echo "OK: {$video['title']} publicado.\n";
}

if ($processedCount > 0) {
    write_log("Worker batch finalizado. Procesados: $processedCount", 'INFO');
}
?>