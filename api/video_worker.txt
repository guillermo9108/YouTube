<?php
/**
 * StreamPay - Server-Side Video Worker V1.4.2 (NAS Optimized)
 * Procesa la cola de videos PENDING con soporte para Audio y Video.
 */

set_time_limit(900);
ini_set('memory_limit', '512M');

require_once 'functions_utils.php';
require_once 'functions_videos.php';

$configFile = 'db_config.json';
if (!file_exists($configFile)) {
    die("[FATAL] db_config.json no encontrado.\n");
}
$config = json_decode(file_get_contents($configFile), true);

try {
    $dsn = "mysql:host={$config['host']};port={$config['port']};dbname={$config['name']};charset=utf8mb4";
    $pdo = new PDO($dsn, $config['user'], $config['password'], [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
    ]);
} catch (Exception $e) { 
    die("[FATAL] Error MariaDB: " . $e->getMessage() . "\n"); 
}

// 1. Obtener y validar FFmpeg
$stmtS = $pdo->query("SELECT ffmpegPath FROM system_settings WHERE id = 1");
$ffmpeg = $stmtS->fetchColumn();

// Si no hay ruta o no es ejecutable, intentar buscarlo
if (!$ffmpeg || !is_executable($ffmpeg)) {
    $search_paths = [
        '/usr/bin/ffmpeg',
        '/usr/local/bin/ffmpeg',
        '/volume1/@appstore/ffmpeg/bin/ffmpeg',
        '/volume1/@appstore/VideoStation/bin/ffmpeg',
        '/volume1/@appstore/CodecPack/bin/ffmpeg',
        'ffmpeg' // fallback a global
    ];
    foreach ($search_paths as $path) {
        if ($path === 'ffmpeg') {
             $output = shell_exec("which ffmpeg");
             if ($output) { $ffmpeg = trim($output); break; }
        } elseif (is_executable($path)) {
            $ffmpeg = $path;
            break;
        }
    }
}

// Autodetección de FFprobe basada en FFmpeg
$ffprobe = (strpos($ffmpeg, DIRECTORY_SEPARATOR) !== false) 
    ? dirname($ffmpeg) . DIRECTORY_SEPARATOR . 'ffprobe' 
    : 'ffprobe';

echo "--- DIAGNÓSTICO DE ENTORNO ---\n";
echo "[INFO] PHP User: " . get_current_user() . " (UID: " . getmyuid() . ")\n";
echo "[INFO] FFmpeg: $ffmpeg " . (is_executable($ffmpeg) ? "[OK]" : "[NO EJECUTABLE]") . "\n";
echo "[INFO] FFprobe: $ffprobe " . (is_executable($ffprobe) ? "[OK]" : "[NO EJECUTABLE]") . "\n";

$batchSize = 10;
$processed = 0;
$failed = 0;

for ($i = 0; $i < $batchSize; $i++) {
    $now = time();
    // Priorizamos videos con menos intentos
    $stmt = $pdo->prepare("SELECT * FROM videos WHERE category = 'PENDING' AND processing_attempts < 3 AND locked_at < ? ORDER BY processing_attempts ASC, createdAt ASC LIMIT 1");
    $stmt->execute([$now - 300]);
    $video = $stmt->fetch();

    if (!$video) {
        echo "[INFO] No hay más videos PENDING.\n";
        break;
    }

    echo "[TAREA " . ($i+1) . "] ID: {$video['id']} - '{$video['title']}' (Intento: {$video['processing_attempts']})\n";

    // Bloqueo
    $pdo->prepare("UPDATE videos SET locked_at = ? WHERE id = ?")->execute([$now, $video['id']]);
    
    $realPath = resolve_video_path($video['videoUrl']);
    
    if (!$realPath || !file_exists($realPath)) {
        echo "[ERROR] Archivo no encontrado en disco: {$video['videoUrl']}\n";
        $pdo->prepare("UPDATE videos SET category = 'FAILED_METADATA', reason = '404: Archivo no encontrado', locked_at = 0 WHERE id = ?")->execute([$video['id']]);
        $failed++;
        continue;
    }

    // A. Extraer Duración (Funciona para Audio y Video)
    $cmdProbe = "$ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 " . escapeshellarg($realPath) . " 2>&1";
    $durOutput = shell_exec($cmdProbe);
    $duration = floor(floatval(trim($durOutput)));

    if ($duration <= 0) {
        echo "[ERROR] Falló FFprobe. Salida: " . ($durOutput ?: "Vacía") . "\n";
        $pdo->prepare("UPDATE videos SET processing_attempts = processing_attempts + 1, locked_at = 0 WHERE id = ?")->execute([$video['id']]);
        $failed++;
        continue;
    }

    // B. Manejo de Miniatura (Detectar si es audio para no fallar en FFmpeg)
    $ext = strtolower(pathinfo($realPath, PATHINFO_EXTENSION));
    $isAudio = (bool)$video['is_audio'] || in_array($ext, ['mp3', 'wav', 'aac', 'm4a', 'flac', 'ogg']);
    $thumbUrl = '';
    $ffCode = 0;
    $ffOutput = [];

    if ($isAudio) {
        // Para audios usamos la miniatura por defecto directamente
        $thumbUrl = 'api/uploads/thumbnails/defaultaudio.jpg';
        echo "[INFO] Audio detectado. Usando miniatura defaultaudio.jpg\n";
    } else {
        // Para videos intentamos extraer un frame
        $thumbFile = 'uploads/thumbnails/' . $video['id'] . '.jpg';
        $fullThumbPath = __DIR__ . '/' . $thumbFile;
        $time = ($duration > 5) ? "00:00:03" : "00:00:01";
        
        $cmdFfmpeg = "$ffmpeg -y -ss $time -i " . escapeshellarg($realPath) . " -frames:v 1 -q:v 4 " . escapeshellarg($fullThumbPath) . " 2>&1";
        exec($cmdFfmpeg, $ffOutput, $ffCode);
        
        if ($ffCode === 0) {
            $thumbUrl = 'api/' . $thumbFile;
        }
    }

    // C. Finalizar Tarea
    if ($ffCode === 0) {
        echo "[SUCCESS] Procesado OK. Duración: $duration s.\n";
        $pdo->prepare("UPDATE videos SET duration = ?, thumbnailUrl = ?, category = 'PROCESSING', locked_at = 0, processing_attempts = 0 WHERE id = ?")
            ->execute([$duration, $thumbUrl, $video['id']]);
        
        // Organización instantánea
        $sets = $pdo->query("SELECT * FROM system_settings WHERE id = 1")->fetch();
        video_organize_single($pdo, $video['id'], $sets);
        $processed++;
    } else {
        $errorMsg = !empty($ffOutput) ? end($ffOutput) : "Error desconocido FFmpeg";
        echo "[ERROR] FFmpeg falló (Code $ffCode): $errorMsg\n";
        $pdo->prepare("UPDATE videos SET processing_attempts = processing_attempts + 1, locked_at = 0 WHERE id = ?")->execute([$video['id']]);
        $failed++;
    }
}

echo "\n--- FINALIZADO: $processed OK, $failed Fallidos ---\n";
?>